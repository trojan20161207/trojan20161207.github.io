<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小冲的生活</title>
  
  <subtitle>笃定</subtitle>
  <link href="https://blog.xiaochong2021.top/atom.xml" rel="self"/>
  
  <link href="https://blog.xiaochong2021.top/"/>
  <updated>2021-11-05T09:01:57.698Z</updated>
  <id>https://blog.xiaochong2021.top/</id>
  
  <author>
    <name>Xiaochong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于Hexo的hexo-theme-matery主题搭建博客并优化</title>
    <link href="https://blog.xiaochong2021.top/2021/11/05/ji-yu-hexo-de-matery-zhu-ti-da-jian-bo-ke-bing-you-hua/"/>
    <id>https://blog.xiaochong2021.top/2021/11/05/ji-yu-hexo-de-matery-zhu-ti-da-jian-bo-ke-bing-you-hua/</id>
    <published>2021-11-05T09:00:00.000Z</published>
    <updated>2021-11-05T09:01:57.698Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 以下是本网站的主题相关配置，方便取用# main menu navigation url and icon# 配置菜单导航的名称、路径和图标icon.menu:  Index:    url: /    icon: fas fa-home  Tags:    url: /tags    icon: fas fa-tags  Categories:    url: /categories    icon: fas fa-bookmark  Archives:    url: /archives    icon: fas fa-archive  About:    url: /about    icon: fas fa-user-circle # Contact: #   url: /contact #   icon: fas fa-comments  Friends:    url: /friends    icon: fas fa-address-book  # 二级菜单写法如下  #Medias:  #  icon: fas fa-list  #  children:  #    - name: Musics  #      url: /musics  #      icon: fas fa-music  #    - name: Movies  #      url: /movies  #      icon: fas fa-film  #    - name: Books  #      url: /books  #      icon: fas fa-book  #    - name: Galleries  #      url: /galleries  #      icon: fas fa-image# Website start time.# 站点运行开始时间.time:  enable: false  year: 2018 # 年份  month: 07 # 月份  date: 23 # 日期  hour: 00 # 小时  minute: 00 # 分钟  second: 00 # 秒# Index cover carousel configuration.# 首页封面轮播图的相关配置.cover:  showPrevNext: true # 是否显示左右切换按钮. Whether to display the left and right toggle buttons.  showIndicators: true # 是否显示指示器. # Whether to display the indicators  autoLoop: true # 是否自动轮播. Whether it is automatically rotated.  duration: 120 # 切换延迟时间. Switching delay time.  intervalTime: 5000 # 自动切换下一张的间隔时间. Automatically switch the interval of the next one.  useConfig: false # 是否使用配置文件, 在 _data/covers.json 下配置推荐文章, false则使用主题在文章中的配置 cover coverImg  # useConfig 使用方式: 将主题 hexo-theme-matery/source/_data/covers.json 移动到 my-blog/source/_data/下修改配置即可# index page dream text,# 配置首页显示"梦想"的语句.dream:  enable: true  showTitle: true  title: 我的梦想  text: 不是每个人都应该像我这样去建造一座水晶大教堂，但是每个人都应该拥有自己的梦想，设计自己的梦想，追求自己的梦想，实现自己的梦想。梦想是生命的灵魂，是心灵的灯塔，是引导人走向成功的信仰。有了崇高的梦想，只要矢志不渝地追求，梦想就会成为现实，奋斗就会变成壮举，生命就会创造奇迹。——罗伯·舒乐# Whether to display the musics.# 是否在首页显示音乐.music:  enable: true  title:  #非吸底模式有效    enable: false    show: 听听音乐  autoHide: false    # hide automaticaly  server: netease   #requiremusic platform: netease, tencent, kugou, xiami, baidu  type: playlist    #require song, playlist, album, search, artist  id: 3019130805     #requiresong id / playlist id / album id / search keyword  fixed: false       # 开启吸底模式  autoplay: false   # 是否自动播放  theme: 'pink'  loop: 'all'       # 音频循环播放, 可选值: 'all', 'one', 'none'  order: 'random'   # 音频循环顺序, 可选值: 'list', 'random'  preload: 'auto'   # 预加载，可选值: 'none', 'metadata', 'auto'  volume: 0.7       # 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效  listFolded: true  # 列表默认折叠  hideLrc: false     # 隐藏歌词# Whether to display the videos.# 是否在首页显示视频.video:  enable: false  showTitle: false  title: 精彩视频What Loves do -- Maroon 5  url:   pic:  thumbnails:  height: # 如：400  autoplay: true # 是否自动播放  theme: '#42b983'  loop: false # 是否循环播放  preload: 'auto' # 预加载，可选值: 'none', 'metadata', 'auto'  volume: 0.7# Whether to display the title of the recommended posts# 是否显示推荐文章的标题recommend:  enable: true  showTitle: true  useConfig: false # 是否使用配置文件, 在 _data/recommends.json 下配置推荐文章, false则会走主题配置的 top 属性  # useConfig 使用方式: 将主题 hexo-theme-matery/source/_data/recommends.json 移动到 my-blog/source/_data/下修改配置即可# Configure website favicon and LOGO# 配置网站favicon和网站LOGOfavicon: /favicon.pnglogo: /medias/logo.png# The configuration of the second button in the home banner,# including the display name of the button, the font awesome icon, and the hyperlink to the button.# 首页 banner 中的第二个按钮的配置，包括按钮的显示名称、font awesome图标和按钮的超链接.indexbtn:  enable: true  name: Github  icon: fab fa-github-alt  url: https://github.com/trojan20161207# The configurations of the second line of home banner# icon/button will not show up if you leave the corresponding socialLink empty# 首页 banner 中的第二行个人信息配置，留空即不启用socialLink:  github:  https://github.com/trojan20161207  email: 1530860548@qq.com  facebook: # https://www.facebook.com/xxx  twitter: # https://twitter.com/xxx  qq: 1530860548  #weibo: # https://weibo.com/xxx  #zhihu: # https://www.zhihu.com/xxx  rss: true # true、false# Whether to activate the Post TOC, and Configure which title types are supported by TOC support.# You can add `toc: false` to the Front-matter of a post to turn off the TOC.# 是否激活文章 TOC 功能，并配置TOC支持选中哪些标题类型，这是全局配置。# 可以在某篇文章的 Front-matter 中再加上`toc: false`，使该篇文章关闭TOC目录功能toc:  enable: true  heading: h2, h3, h4  collapseDepth: 0 # 目录默认展开层级  showToggleBtn: true # 是否显示切换TOC目录展开收缩的按钮# 代码块相关code:  lang: true # 代码块是否显示名称  copy: true # 代码块是否可复制  shrink: true # 代码块是否可以收缩  break: true # 代码是否折行# 是否激活文章末尾的打赏功能，默认激活（你替换为的你自己的微信、支付宝二维码图片、或者使用网络图片也可以）.reward:  enable: true  title: 你的赏识是我前进的动力  wechat: /medias/reward/wechat.png  alipay: /medias/reward/alipay.jpg# Whether to activate the copyright information of the blog and author when copying the post content.# minCharNumber: Approve copyright information by copying at least how many characters.# 是否激活复制文章时追加博客和作者的版权信息.copyright:  enable: false  minCharNumber: 120 # 至少复制多少个字符就追加版权信息.  description: 本文章著作权归作者所有，任何形式的转载都请注明出处。# Whether to activate the mathjax, this is a global configuration, but the post still does not open the mathjax rendering.# Considering that the mathjax loading is time consuming,# you also need to add `mathjax: true` to the Front-matter of the post that needs to be rendered.# 是否激活mathjax数学公式，这是全局配置，但文章仍然不会都开启mathjax渲染，# 考虑到mathjax加载比较耗时，你还需要在需要渲染的文章的Front-matter中再加上`mathjax: true`才行.mathjax:  enable: true  cdn:  https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML# Post word count, reading duration, site total word count.# Before you activate, please confirm that you have installed the hexo-wordcount plugin,# install the plugin command: `npm i --save hexo-wordcount`.# 文章字数统计、阅读时长、总字数统计等# 文章信息--若要开启文章字数统计，需要安装 hexo-wordcount 插件，安装命令: `npm i --save hexo-wordcount`postInfo:  date: true # 发布日期  update: false # 更新日期  wordCount: false # 文章字数统计  totalCount: false # 站点总文章字数  min2read: false # 文章阅读时长  readCount: false # 文章阅读次数# Whether to activate the 'love' effect of clicking on the page.# 是否激活点击页面的'爱心'效果，默认激活.clicklove:  enable: true# profile in about page, including avatars, career, and personal introductions.# 在”关于”页面中配置个人信息，包括头像、职业和个人介绍.profile:  avatar: /medias/avatar.jpg  career: DevOps Engineer  introduction: If you wish to succeed, you should use persistence as your good friend, experience as your reference, prudence as your brother and hope as your sentry.# config my projects informations in about page.# If you don't want to display this `My Projects` content, you can deactivate or delete this configuration.# 在“关于”页面配置"我的项目"信息，如果你不需要这些信息则可以将其设置为不激活或者将其删除.myProjects:  enable: true  data:    hexo-theme-matery:      icon: fas fa-file-alt      iconBackground: 'linear-gradient(to bottom right, #66BB6A 0%, #81C784 100%)'      url: http://github.com/blinkfox/hexo-theme-matery      desc: This is a Hexo blog theme with 'Material Design' and responsive design.    Fenix:        icon: fas fa-database        iconBackground: 'linear-gradient(to bottom right, #F06292 0%, #EF5350 100%)'        url: https://github.com/blinkfox/fenix        desc: 这是 Spring Data JPA 复杂或动态 SQL 查询的扩展库。    typora-vue-theme:        icon: fas fa-file-alt        iconBackground: 'linear-gradient(to bottom right, #29B6F6 0%, #1E88E5 100%)'        url: https://github.com/blinkfox/typora-vue-theme        desc: This is a typora theme inspired by Vue document style.# config my skills informations in about page.# If you don't want to display this `My Skills` content, you can deactivate or delete this configuration.# 在“关于”页面配置"我的技能"信息，如果你不需要这些信息则可以将其设置为不激活或者将其删除.mySkills:  enable: true  data:    Linux:      background: 'linear-gradient(to right, #FF0066 0%, #FF00CC 100%)'      percent: 85%    Shell:      background: 'linear-gradient(to right, #9900FF 0%, #CC66FF 100%)'      percent: 80%    Go:      background: 'linear-gradient(to right, #2196F3 0%, #42A5F5 100%)'      percent: 80%    CSS:      background: 'linear-gradient(to right, #00BCD4 0%, #80DEEA 100%)'      percent: 70%    SQL:      background: 'linear-gradient(to right, #4CAF50 0%, #81C784 100%)'      percent: 90%    程序设计:      background: 'linear-gradient(to right, #FFEB3B 0%, #FFF176 100%)'      percent: 75%# config gallery of my photos in about page.# If you don't want to display this `Gallery` content, you can deactivate or delete this configuration.# 在“关于”页面配置"我的相册"图片，如果你不需要这些信息则可以将其设置为不激活或者将其删除.myGallery:  enable: true  data:    - /medias/featureimages/0.jpg    - /medias/featureimages/1.jpg    - /medias/featureimages/2.jpg    - /medias/featureimages/3.jpg    - /medias/featureimages/4.jpg    - /medias/featureimages/5.jpg    - /medias/featureimages/6.jpg    - /medias/featureimages/7.jpg    - /medias/featureimages/8.jpg    - /medias/featureimages/9.jpg    - /medias/featureimages/10.jpg    - /medias/featureimages/11.jpg    - /medias/featureimages/12.jpg    - /medias/featureimages/13.jpg    - /medias/featureimages/14.jpg    - /medias/featureimages/15.jpg    - /medias/featureimages/16.jpg    - /medias/featureimages/17.jpg    - /medias/featureimages/18.jpg    - /medias/featureimages/19.jpg    - /medias/featureimages/20.jpg    - /medias/featureimages/21.jpg    - /medias/featureimages/22.jpg    - /medias/featureimages/23.jpg# Whether to display post-calender in the `archive` page# 设置在归档页面中是否显示'文章日历'控件postCalendar: true# 不建议使用gittalk,gitment这样权限过高的oauth app,因为它们能够 读写 授权者 所有的公共仓库 ，也就是说拿到你的授权 Token 的人，可以将你的 GitHub 公共仓库删空（这是github权限分的不够细的锅），如果恶意攻击者想获取使用者的 AccessToken，只需要在代码中加上一个 ajax 请求即可。原贴地址:https://www.v2ex.com/t/535608。建议大家看完。（我没有在用gittalk/gitment的网站上评论过，但根据v2ex网友的提示，如果网站自行修改了 gitalk.js 脚本 或者反代了 github api，就很容易拿到你的 Token ）# https://github.com/utterance/utterances 是个 GitHub App，它的权限仅限于某个仓库。像 hugo hexo 这种静态页面类型的博客，clientID/clientSecret 泄露是不可避免的。我认为较好的解决方式是像 utteras 这种 GitHubApp，只有一个仓库的读写权限，将破坏降到最小。# valine和minivaline都是使用的免费的leancloud开发版资源，即使数据丢了leancloud也不用负任何的责任。此外valine的src目录已在1.4.0后停止更新。。。薛定谔的开源。# 当初多说国内最大都倒了，livere不一定靠谱。# disqus被墙了。# 畅言需要备案。# the Gitalk config，default disabled# Gitalk 评论模块的配置，默认为不激活gitalk:  enable: false  owner:  repo:  oauth:    clientId:    clientSecret:  admin:# the Gitment config，default disabled# Gitment 评论模块的配置，默认为不激活gitment:  enable: false  owner:  repo:  oauth:    clientId:    clientSecret:# disqus config, default disabled# Disqus评论模块的配置，默认为不激活disqus:  enable: false  shortname:# Livere comment configuration, the default is not activated# Livere 来必力评论模块的配置，默认为不激活livere:  enable: false  uid:# The configuration of the Valine comment module is not activated by default.# To use it, activate the configuration item and set appId and appKey.# Valine 评论模块的配置，默认为不激活，如要使用，就请激活该配置项，并设置 appId 和 appKey.valine:  enable: false  appId:  appKey:  notify: false  verify: false  visitor: true  avatar: 'mm' # Gravatar style : mm/identicon/monsterid/wavatar/retro/hide  pageSize: 10  placeholder: 'just go go' # Comment Box placeholder  background: /medias/comment_bg.png# The configuration of the MiniValine comment module is not activated by default.# To use it, activate the configuration item and set appId and appKey.# MiniValine 评论模块的配置，默认为不激活，如要使用，就请激活该配置项，并设置 appId 和 appKey.# See: https://github.com/MiniValine/MiniValineminivaline:  enable: false  appId: zhM0AOiqle17oPoE84CoYw1e-gzGzoHsz # Your leancloud application appid  appKey: itmzT1JbXfAjVwMqDhGPzU45 # Your leancloud application appkey  mode: DesertsP # DesertsP or xCss  placeholder: Write a Comment # Comment box placeholder  math: true # Support MathJax.  md: true # Support Markdown.  enableQQ: false # Enable QQ avatar API.  NoRecordIP: false # Do not record commenter IP.  visitor: true # Article reading statistics.  maxNest: 6 # Sub-comment maximum nesting depth.  pageSize: 6 # Pagination size.  adminEmailMd5: de8a7aa53d07e6b6bceb45c64027763d # The MD5 of Admin Email to show Admin Flag.[Just Only DesertsP Style mode]  tagMeta: # The String Array of Words to show Flag.[Just Only xCss Style mode]    - 管理员    - 小伙伴    - 访客  master: # The MD5 String Array of master Email to show master Flag.[Just Only xCss Style mode]    - de8a7aa53d07e6b6bceb45c64027763d  friends: # The MD5 String Array of friends Email to show friends Flag.[Just Only xCss Style mode]    - b5bd5d836c7a0091aa8473e79ed4c25e    - adb7d1cd192658a55c0ad22a3309cecf    - 3ce1e6c77b4910f1871106cb30dc62b0    - cfce8dc43725cc14ffcd9fb4892d5bfc  # MiniValine's display language depends on user's browser or system environment  # If you want everyone visiting your site to see a uniform language, you can set a force language value  # Available values: en  | zh-CN | (and many more)  # More i18n info: https://github.com/MiniValine/minivaline-i18n  lang:  # Expression Url.  # https://github.com/MiniValine/MiniValine/blob/master/.github/FAQ.md#how-to-customize-emoticons  emoticonUrl:    - https://cdn.jsdelivr.net/npm/alus@latest    - https://cdn.jsdelivr.net/gh/MiniValine/qq@latest    - https://cdn.jsdelivr.net/gh/MiniValine/Bilibilis@latest    - https://cdn.jsdelivr.net/gh/MiniValine/tieba@latest    - https://cdn.jsdelivr.net/gh/MiniValine/twemoji@latest    - https://cdn.jsdelivr.net/gh/MiniValine/weibo@latestchangyan:  enable: false  appId:  conf:# Whether to display fork me on github icon and link, default true, You can change it to your repo address# 配置是否在 header 中显示 fork me on github 的图标，默认为true，你可以修改为你的仓库地址.githubLink:  enable: true  url: https://github.com/trojan20161207  title: Fork Me# The password verification feature of read post. To use this feature,# activate the configuration item and write the 'password' key and Cipher in the post's Front-matter.# Note: In order to ensure that the original password will not be leaked to the web page,# the password of the article must be encrypted by 'SHA256' so that it will not be cracked.# 阅读文章的密码验证功能，如要使用此功能请激活该配置项，并在对应文章的Front-matter中写上'password'的键和加密后的密文即可.# 请注意：为了保证密码原文不会被泄露到网页中，文章的密码必须是通过'SHA256'加密的，这样就不会被破解.verifyPassword:  enable: false  promptMessage: 请输入访问本文章的密码  errorMessage: 密码错误，将返回主页！# busuanzi(http://busuanzi.ibruce.info/) website statistics# 不蒜子(http://busuanzi.ibruce.info/) 网站统计busuanziStatistics:  enable: true  totalTraffic: true # 总访问量  totalNumberOfvisitors: true # 总人次# Add google analytics configuration# 添加 Google Analytics 配置googleAnalytics:  enable: false  id:# Add baidu analytics configuration# 添加 baidu Analytics 配置baiduAnalytics:  enable: false  id:# 百度搜索资源平台提交链接baiduPush: false# The used front-end library can be replaced with the corresponding CDN address as needed,# If the specific version is not specified below, you can use the latest version.# 使用到的前端库，可按需替换成对应的CDN地址，如果下面未指定具体的版本号，使用最新的版本即可.# 注：jsdelivr可以自动帮你生成.min版的js和css，所以你在设置js及css路径中可以直接写.min.xxxlibs:  css:    matery: /css/matery.css    mycss: /css/my.css    fontAwesome: /libs/awesome/css/all.css # V5.11.1    materialize: /libs/materialize/materialize.min.css # 1.0.0    aos: /libs/aos/aos.css    animate: /libs/animate/animate.min.css # V3.5.1    lightgallery: /libs/lightGallery/css/lightgallery.min.css # V1.6.11    aplayer: /libs/aplayer/APlayer.min.css    dplayer: /libs/dplayer/DPlayer.min.css    gitalk: /libs/gitalk/gitalk.css    jqcloud: /libs/jqcloud/jqcloud.css    tocbot: /libs/tocbot/tocbot.css    prism: /libs/prism/prism.css  js:    matery: /js/matery.js    jquery: /libs/jquery/jquery.min.js    materialize: /libs/materialize/materialize.min.js # 1.0.0    masonry: /libs/masonry/masonry.pkgd.min.js # v4.0.0    aos: /libs/aos/aos.js    scrollProgress: /libs/scrollprogress/scrollProgress.min.js    lightgallery: /libs/lightGallery/js/lightgallery-all.min.js # V1.6.11    clicklove: /libs/others/clicklove.js    busuanzi: /libs/others/busuanzi.pure.mini.js    aplayer: /libs/aplayer/APlayer.min.js    dplayer: /libs/dplayer/DPlayer.min.js    crypto: /libs/cryptojs/crypto-js.min.js    echarts: /libs/echarts/echarts.min.js    gitalk: /libs/gitalk/gitalk.min.js    valine: /libs/valine/Valine.min.js # 若想保持最新版，请替换为 https://unpkg.com/valine/dist/Valine.min.js  默认为 /libs/valine/Valine.min.js    minivaline: /libs/minivaline/MiniValine.js    jqcloud: /libs/jqcloud/jqcloud-1.0.4.min.js    tocbot: /libs/tocbot/tocbot.min.js    canvas_nest: /libs/background/canvas-nest.js    ribbon: /libs/background/ribbon.min.js    ribbonRefresh: /libs/background/ribbon-refresh.min.js    ribbon_dynamic: /libs/background/ribbon-dynamic.js    instantpage: /libs/instantpage/instantpage.js# The post featured images that needs to be displayed when there is no image.# 无文章特色图片时需要显示的文章特色图片.featureImages:- /medias/featureimages/0.jpg- /medias/featureimages/1.jpg- /medias/featureimages/2.jpg- /medias/featureimages/3.jpg- /medias/featureimages/4.jpg- /medias/featureimages/5.jpg- /medias/featureimages/6.jpg- /medias/featureimages/7.jpg- /medias/featureimages/8.jpg- /medias/featureimages/9.jpg- /medias/featureimages/10.jpg- /medias/featureimages/11.jpg- /medias/featureimages/12.jpg- /medias/featureimages/13.jpg- /medias/featureimages/14.jpg- /medias/featureimages/15.jpg- /medias/featureimages/16.jpg- /medias/featureimages/17.jpg- /medias/featureimages/18.jpg- /medias/featureimages/19.jpg- /medias/featureimages/20.jpg- /medias/featureimages/21.jpg- /medias/featureimages/22.jpg- /medias/featureimages/23.jpg# default configs that the default policy for every articles/posts# default 配置文章的默认转载规则# you can define reprint policy for a single article in the front-matter of the specific md file using this key: reprintPolicy# 您可以使用在文章md文件的 front-matter 中指定 reprintPolicy 来给单个文章配置转载规则# 可用的转载规则有（available reprint policies are）：# 这些转载规则的意义请参考(you can refer to this link FMI)：https://creativecommons.org/choose/?lang=zh# cc_by（知识共享署名 4.0 国际许可协议 Creative Commons Attribution-NoDerivatives 4.0 International License）# cc_by_nd（知识共享署名-禁止演绎 4.0 国际许可协议 Creative Commons Attribution-NoDerivatives 4.0 International License）# cc_by_sa（知识共享署名-相同方式共享 4.0 国际许可协议 Creative Commons Attribution-ShareAlike 4.0 International License）# cc_by_nc（知识共享署名-非商业性使用 4.0 国际许可协议 Creative Commons Attribution-NoDerivatives 4.0 International License）# cc_by_nc_nd（知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议 Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License）# cc_by_nc_sa（知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议 Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License）# cc0（CC0 1.0 通用 (CC0 1.0) 公共领域贡献 CC0 1.0 Universal (CC0 1.0) Public Domain Dedication） https://creativecommons.org/publicdomain/zero/1.0/deed.zh# noreprint（不允许转载 not allowed to reprint）# pay（付费转载 pay for reprinting）reprint:  enable: true # whether enable reprint section 是否启用“转载规则限定模块”  default: cc_by# DaoVoice online contactdaovoice:  enable: false  app_id:# Tidio online contacttidio:  enable: false  public_key:# 腾讯兔小巢，见https://txc.qq.com/tuxiaochao:  enable: false  productId:#背景canvas-nestcanvas_nest:  enable: false  color: 0,0,255 # 线条颜色, 默认: '0,0,0' ；三个数字分别为(R,G,B)，注意用,分割  pointColor: 0,0,255 # 交点颜色, 默认: '0,0,0' ；三个数字分别为(R,G,B)，注意用,分割  opacity: 0.7 # 线条透明度（0~1）, 默认: 0.5  zIndex: -1 # 背景的 z-index 属性，css 属性用于控制所在层的位置, 默认: -1.  count: 99 # 线条的总数量, 默认: 99# 背景静止彩带.ribbon:  enable: false  size: 150 # 彩带大小, 默认: 90.  alpha: 0.6 # 彩带透明度 (0 ~ 1), 默认: 0.6.  zIndex: -1 # 背景的z-index属性，css属性用于控制所在层的位置, 默认: -1.  clickChange: false  # 设置是否每次点击都更换彩带.# 背景动态彩带.ribbon_dynamic:  enable: false# sharejs文章分享模块.# 支持顺序，可选项目为twitter, facebook, google, qq, qzone, wechat, weibo, douban, linkedin.sharejs:  enable: true  sites: google,qq,qzone,wechat,weibo# addthis文章分享模块.addthis:  enable: false  pubid:  # 前往https://www.addthis.com/获取# 打字效果副标题.# 如果有符号 ‘ ，请在 ’ 前面加上 \subtitle:  enable: true  loop: true # 是否循环  showCursor: true # 是否显示光标  startDelay: 300 # 开始延迟  typeSpeed: 100 # 打字速度  backSpeed: 50 # 删除速度  sub1: 从来没有真正的绝境, 只有心灵的迷途  sub2: Never really desperate, only the lost of the soul  sub3: 用心过每一天，就像那是你生命中的最后一天  sub4: Live every day with your heart, as if it was the last day in your life  sub5: 用心做好每一件事，因为那可能是你能做的最后一件事  sub6: Do everything with your heart, because that may be the last thing you can do# 手机二级菜单.navMenu:  mleft: true # 二级侧栏子菜单是否对齐左边  bgColor: " " # 二级侧栏子菜单背景颜色,留空即为全局背景色# 网页预加载.instantpage:  enable: true# banner 是否每日切换.# 若为 false, 则 banner 默认为 /medias/banner/0.jpgbanner:  enable: true#ICP备案信息尾部显示icp:  enable: false  url: # 备案链接  text: # 备案信息# CDN访问加速 # 第一次使用本功能，一定要先配置url，再`hexo cl &amp;&amp; hexo g &amp;&amp; hexo d`部署到GitHub的仓库，注意！必须是GitHub的仓库！# 如果必须要使用国内的coding或者gitee，可以采用双部署，同时将网站部署到两个仓库（其中一个必须是GitHub的仓库）# URL配置规则（例子如下）： https://cdn.jsdelivr.net/gh/你的GitHub用户名/你的仓库名# 如果想关闭此功能，将 url地址 注释或删除即可！## 注：配置了此项，就代表着本地调试的时候，网站依然会去GitHub请求资源（原来的资源），本地调试的时候记得将 此项配置 注释或者删除掉# 更多关于访问速度优化，请查看：https://blog.sky03.cn/posts/42790.html# 注：jsdelivr可以自动帮你生成.min版的js和css，所以你在上面设置js及css路径中可以直接写.min.xxxjsDelivr:  url: https://cdn.jsdelivr.net/gh/trojan20161207/trojan20161207.github.io  # 网站背景图background:  enable: false  url: https://cdn.jsdelivr.net/gh/trojan20161207/trojan20161207.github.io/medias/featureimages/13.jpg# 说说 https://artitalk.js.org/artitalk:  enable: false  appId: # xxxxx  appKey: # xxxxxx# 哔哔功能配置# 登陆leancloud创建应用。进入应用后，点击创建 Class，将「 Class 名称」命名为 content# 点击刚刚创建的content Class，点击添加列并创建名称为content的列，类型为String，注意列注释也要填写（随意填）# 记录appid，masterkey，api域名# 输入:hexo new page bb# hexo就在source文件夹下创建了bb/index.md。# 修改index.md的frontmater下的layout为bb：# ---# title: 黑石说# layout: bb# ---# 里面的文字可以自己随意加，会显示在哔哔的上方。# 关注公众号 "黑石哔哔"，发送: //bindCurrentUser:你的APPID,你的MASTERKEY,你的RESTAPI# 可用leancloud国际版，国际版api为 https://appid前八位.api.lncldglobal.combbtime: enable: false appId: # 你的appId appKey: # 你的appKey serverURLs: # https://你的api<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="blog" scheme="https://blog.xiaochong2021.top/tags/blog/"/>
    
    <category term="hexo" scheme="https://blog.xiaochong2021.top/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>go语言参考手册</title>
    <link href="https://blog.xiaochong2021.top/2021/11/05/go-yu-yan-can-kao-shou-ce/"/>
    <id>https://blog.xiaochong2021.top/2021/11/05/go-yu-yan-can-kao-shou-ce/</id>
    <published>2021-11-05T02:17:00.000Z</published>
    <updated>2021-11-05T02:18:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>这是一个 Go 语言的参考手册，你也可以访问<a href="https://golang.org/">golang.org</a>获取更多信息和其他文档。</p><p>Go 是在设计时考虑了系统编程的通用型编程语言。它是强类型，有垃圾回收机制并原生支持并发编程。Go 程序由一个或多个 package 组成，这样可以高效的管理依赖。</p><p>Go 的语法简洁且有规则，这让自动化工具可以很容易的分析代码，例如：集成开发环境。</p><h2 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h2><p>语法采用扩展巴科斯范式。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">Production  = production_name "=" [ Expression ] "." .Expression  = Alternative { "|" Alternative } .Alternative = Term { Term } .Term        = production_name | token [ "…" token ] | Group | Option | Repetition .Group       = "(" Expression ")" .Option      = "[" Expression "]" .Repetition  = "{" Expression "}" .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>产生式是由词法单元和以下操作符构成的表达式（优先级依次递增）：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">|   或()  分组[]  可选 (出现 0 或 1 次){}  可重复 (出现 0 到 n 次)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>小写的产生式名称用来与词法单元区分。非终结符采用驼峰式。词法单元由双引号或反引号组成。</p><p><code>a...b</code> 表示从 <code>a</code> 到 <code>b</code> 之间的任意字符。省略号 <code>...</code> 也可以在规范中表示对更详细的枚举和代码片段的省略。字符 <code>...</code> 不是 Go 语言的词法单元。</p><h2 id="源码表示法"><a href="#源码表示法" class="headerlink" title="源码表示法"></a>源码表示法</h2><p>Go 的源代码使用 UTF-8 编码的 Unicode 文本。不过它并不是完全规范化的，单重音的代码点与由相同字符和音标组成的代码点是不同的；前者我们认为它是两个代码点。简单来讲，文档会在源代码文本中使用非规范的术语字符来表示一个 Unicode 代码点。</p><p>每个代码点都是不同的；相同字符的大写和小写形式表示不同的字符。</p><p>实现限制：为了兼容其他工具，编译器不允许出现 Utf-8 编码的源文本中的 NUL 字符（U+0000）。</p><p>实现限制：为了兼容其他工具，如果源文本中是以Utf-8 编码的字节序标记（U+FEFF）为起始代码点。编译器会忽略它。字节序标记不应出现在源文本的任何位置。</p><h4 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h4><p>这些单词表示 Unicode 字符的类别：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">newline        = /* Unicode 代码点 U+000A */ .unicode_char   = /* 排除换行以外的任意 Unicode 代码点 */ .unicode_letter = /* 一个字母（"Letter"）类型的 Unicode 代码点  */ .unicode_digit  = /* 一个数字（"Number, decimal digit"）类型的 Unicode 代码点  */ .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在 Unicode8.0 标准中，第 4.5 章节 “一般类别” 中定义了字符的类别。Go 能够处理任何字符集，包括 Lu，Li，Lt，Lm 或 Lo 作为 Unicode 字母，还可以把数字字符集 Nd 当作 Unicode 数字处理。</p><h4 id="字母和数字"><a href="#字母和数字" class="headerlink" title="字母和数字"></a>字母和数字</h4><p>我们认为下划线 <code>_</code> （U+005F）是一个字母：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">letter        = unicode_letter | "_" .decimal_digit = "0" … "9" .octal_digit   = "0" … "7" .hex_digit     = "0" … "9" | "A" … "F" | "a" … "f" .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="词汇元素"><a href="#词汇元素" class="headerlink" title="词汇元素"></a>词汇元素</h2><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>注释是程序的说明文档。在 Go 中有两种形式：</p><ul><li>单行注释从 <code>//</code> 开始直到行末结束。</li><li>通用注释从 <code>/*</code> 开始直到 <code>*/</code> 结束。</li></ul><p>注释不能嵌套在其他注释、字符串和 rune 的字面值中。不包含换行符的通用注释之间通过空格符连接，其他情况下每段注释都会另起一行。</p><h4 id="词汇元素-1"><a href="#词汇元素-1" class="headerlink" title="词汇元素"></a>词汇元素</h4><p>词汇元素构成了 Go 语言的词汇表。它有四种类型：标识符、关键字、操作符/标点符号、字面值。空白符可以是空格（U+0020）、水平制表符（U+0009）、换行符（U+000D）或换行符（U+000A）。它本身会被忽略，一般用来区分不同的词汇元素。换行符或文件终止符（EOF）还可能触发编译程序在源代码的行末或文件末尾追加分号。在分解源代码的词汇元素的过程中，会把当前可以形成有效词汇元素的最长字符序列作为下一个词汇元素。</p><h4 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h4><p>正规语法在很多产生式中使用分号 “;” 作为终结符。Go 程序中遵循下面两条规则省略了大部分的分号：</p><ol><li>当某行的最后一个词汇元素是以下元素时自动补全分号：</li></ol><ul><li><p>一个标识符。</p></li><li><p>一个整数，浮点数，虚数，rune 或字符串字面值。</p></li><li><p>关键字 <code>break</code>、<code>continue</code>、<code>fallthrough</code> 和 <code>return</code> 其中之一。</p></li><li><p>操作符/标点符号 <code>++</code>，<code>--</code>，<code>)</code>，<code>]</code> 和 <code>}</code> 其中之一。</p></li></ul><ol><li>为了支持独占一行的复杂语句，会省略与 “)” 或 “}” 相邻的分号。</li></ol><p>为了反应惯用用途，本篇文档的所有例子都基于以上规则省略分号。</p><h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h4><p>标识符表示程序实体单元，例如：变量、类型。一个标识符由一个或多个字母和数字组成。标识符的首字符必须为字母。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">identifier = letter { letter | unicode_digit } .<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">a_x9ThisVariableIsExportedαβ<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Go 已经预定义了一些标识符。</p><h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><p>以下关键字是预留的，它们不能作为标识符：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">break        default      func         interface    selectcase         defer        go           map          structchan         else         goto         package      switchconst        fallthrough  if           range        typecontinue     for          import       return       var<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="操作符和标点符号"><a href="#操作符和标点符号" class="headerlink" title="操作符和标点符号"></a>操作符和标点符号</h4><p>以下字符序列用于表示操作符（包括赋值运算符）和标点符号：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">+    &amp;     +=    &amp;=     &amp;&amp;    ==    !=    (    )-    |     -=    |=     ||    &lt;     &lt;=    [    ]*    ^     *=    ^=     &lt;-    &gt;     &gt;=    {    }/    &lt;&lt;    /=    &lt;&lt;=    ++    =     :=    ,    ;%    &gt;&gt;    %=    &gt;&gt;=    --    !     ...   .    :     &amp;^          &amp;^=<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="整型字面值"><a href="#整型字面值" class="headerlink" title="整型字面值"></a>整型字面值</h4><p>整型字面值是一个数字序列，相当于整型常量。可以使用前缀指定非小数进制：0 表示八进制，0x/0X 表示十六进制。在十六进制字面值中，字母 a-f 和 A-F 都表示数字 10-15。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">int_lit     = decimal_lit | octal_lit | hex_lit .decimal_lit = ( "1" … "9" ) { decimal_digit } .octal_lit   = "0" { octal_digit } .hex_lit     = "0" ( "x" | "X" ) hex_digit { hex_digit } .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">4206000xBadFace170141183460469231731687303715884105727<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="浮点字面值"><a href="#浮点字面值" class="headerlink" title="浮点字面值"></a>浮点字面值</h4><p>浮点字面值是一个小数，相当于浮点数常量。它由整数部分，小数点，小数部分和指数部分构成。整数部分和小数部分用小数点链接；指数部分由  <code>e</code> / <code>E</code> 字符后接一个有符号指数构成。整数部分和小数部分可以省略其一；小数点和指数部分可以省略其一。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">float_lit = decimals "." [ decimals ] [ exponent ] |            decimals exponent |            "." decimals [ exponent ] .decimals  = decimal_digit { decimal_digit } .exponent  = ( "e" | "E" ) [ "+" | "-" ] decimals .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">0.72.40072.40  // == 72.402.718281.e+06.67428e-111E6.25.12345E+5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="虚数字面值"><a href="#虚数字面值" class="headerlink" title="虚数字面值"></a>虚数字面值</h4><p>虚数字面值是一个小数，相当于复数常量中的虚数部分。它由浮点数或者整数后接小写字母 i 构成。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">imaginary_lit = (decimals | float_lit) "i" .<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">0i011i  // == 11i0.i2.71828i1.e+0i6.67428e-11i1E6i.25i.12345E+5i<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Rune-字面值"><a href="#Rune-字面值" class="headerlink" title="Rune 字面值"></a>Rune 字面值</h4><p>rune 类型字面值相当于一个 rune 常量。它是一个表示 Unicode 代码点的整数。rune 类型字面值表示为用单引号包裹的一个或多个字符，像 ‘x’ 或 ‘\n’。在单引号中除了换行符和未转义的单引号其他的字符都可以直接显示。单引号包裹的字符的值和字符在 Unicode 编码中的值相等，而以反斜线开头的多字符序列会把值翻译成多种格式。</p><p>使用引号表示单字符是最简单的方式；因为 Go 的源文本是 UTF-8 编码，一个整数可能代表多个 UTF-8 字节。例如， ‘a’ 可以使用单字节表示字符 a，Unicode 编码 U+0061，值 0x61，而 ‘ä’ 是两字节表示分音符的 a，Unicode 编码 U+00E4，值 0xe4。</p><p>反斜线能将任意值编码成 ASCII 文本。有四种方式将整数值表示为数字常量：<code>\x</code> 后接两个十六进制数；<code>\u</code> 后接四个十六进制数；<code>\U</code> 后接八个十六进制数。 <code>\</code> 后接三个八进制数。每种情况下都使用相应进制来表示字面量的整数值。</p><p>虽然这四种方式都以整数表示，但它们的有效区间并不相同。八进制只能表示 0 - 255 以内的整数。十六进制满可以满足需求。<code>\u</code> 和 <code>\U</code>  都可以表示 Unicode 代码点，不过其中的一些值是无效的，特别是 0x10FFFF 以上的值。</p><p>反斜线结合以下字符具有特殊含义：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">\a   U+0007 alert or bell\b   U+0008 退格符\f   U+000C form feed\n   U+000A line feed or newline\r   U+000D carriage return\t   U+0009 水平制表符\v   U+000b 垂直制表符\\   U+005c 反斜线\'   U+0027 单引号  (只在 rune 字面值中有效)\"   U+0022 双引号  (只在字符串字面值中有效)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其他所有以反斜线开头的序列在 rune 的规则中都是非法的。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">rune_lit         = "'" ( unicode_value | byte_value ) "'" .unicode_value    = unicode_char | little_u_value | big_u_value | escaped_char .byte_value       = octal_byte_value | hex_byte_value .octal_byte_value = `\` octal_digit octal_digit octal_digit .hex_byte_value   = `\` "x" hex_digit hex_digit .little_u_value   = `\` "u" hex_digit hex_digit hex_digit hex_digit .big_u_value      = `\` "U" hex_digit hex_digit hex_digit hex_digit                           hex_digit hex_digit hex_digit hex_digit .escaped_char     = `\` ( "a" | "b" | "f" | "n" | "r" | "t" | "v" | `\` | "'" | `"` ) .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">'a''ä''本''\t''\000''\007''\377''\x07''\xff''\u12e4''\U00101234''\''         // 包含单引号的 rune 字面值'aa'         // 无效: 太多字符'\xa'        // 无效: 缺少十六进制数'\0'         // 无效: 缺少八进制数'\uDFFF'     // 无效: surrogate half'\U00110000' // 无效: 非法的 Unicode 代码点<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="字符串字面量"><a href="#字符串字面量" class="headerlink" title="字符串字面量"></a>字符串字面量</h4><p>字符串字面量表示从字符序列中获取的字符串常量。它有两种格式：原始字符串字面量和解释型字符串字面量。</p><p>原始字符串是由反引号包裹（<code>foo</code>）。字符串中除反引号以外的其他字符都会显示出来。原生字符串由反引号之间的（默认 UTF-8 编码）的字符组成。它的值为引号内未经解释（默认 UTF-8 编码）所有字符；尤其是，反斜线再字符串中没有特殊意义并且字符串中保留换行符。在原始字符串的值中会丢弃回车键返回 ‘\r’ 字符。</p><p>解释型字符串由双引号之间的字符组成（”bar”）。除了换行符和双引号其他字符都会显示出来。双引号之间的文本组成字面量的值。反斜线的转义规则与 rune 字面量基本相同（不同的是 \’ 非法，而 " 合法）。三位八进制数（\nnn）和两位十六进制数（\xnn）换码符的值表示相应字符串的字节。其他的换码符都表示字符各自的 UTF-8 编码（可能是多字节）。因此字符串 \377 和 \xFF 都表示值为 0xFF=255 的单个字节，而  <code>ÿ</code>, <code>\u00FF</code>, <code>\U000000FF</code> 和 <code>\xc3\xbf</code> 表示 UTF-8 编码字符 U+00FF 的两个字节 0xc3 0xbf。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">string_lit             = raw_string_lit | interpreted_string_lit .raw_string_lit         = "`" { unicode_char | newline } "`" .interpreted_string_lit = `"` { unicode_value | byte_value } `"` .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">`abc`                // 等价于 "abc"`\n\n`                  // 等价于 "\\n\n\\n""\n""\""                 // 等价于 `"`"Hello, world!\n""日本語""\u65e5本\U00008a9e""\xff\u00FF""\uD800"             // 无效: surrogate half"\U00110000"         // 无效: 无效的 Unicode 代码点<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这些例子都表示相同的字符串：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">"日本語"                                 // UTF-8 文本`日本語`                                 // UTF-8 文本作为原生字面值"\u65e5\u672c\u8a9e"                    // 确定的 Unicode 代码点 "\U000065e5\U0000672c\U00008a9e"        // 确定的 Unicode 代码点"\xe6\x97\xa5\xe6\x9c\xac\xe8\xaa\x9e"  // 确定的 UTF-8 字节<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果源代码中使用两个代码点表示一个字符，例如带音标的字母，把它放在 rune 中会报错（它不是单代码点）。并且在字符串中会显示两个代码点。</p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量分为：布尔型，rune型，整型，浮点型，复数型，字符串型。其中 rune，整型，浮点型，复数型统称为数字常量。</p><p>常量的值可以表示为一个 rune字面量，整数字面量，浮点数字面量，虚数字面量，字符串字面量，表示常量的标识符，常量表达式，一个转换结果为常量的类型转换，和一些返回值为常量的内置函数(接受任何值的<code>unsafe.Sizeof</code>，接受部分表达式的<code>cap</code> 或 <code>len</code>，接受虚数常量的<code>real</code> 和 <code>imag</code>，接受数字常量的 <code>complex</code>)。布尔类型的值为预定义常量 <code>true</code> 或 <code>false</code>，预定义的标识符 <code>iota</code> 表示一个整型常量。</p><p>一般情况下复数常量是常量表达式的一种形式。会在常量表达式章节详细讨论。</p><p>数字常量可以表示任意精度的确定值而且不会溢出。因此，没有常量可以表示非 0，无穷大和非数字值。</p><p>常量可以指定类型也可以不指定类型。字面值常量，<code>true</code>，<code>false</code>，<code>iota</code>，和只包含无类型常量操作的常量表达式是无类型的。</p><p>常量可以通过常量声明和转换时显式的指定具体类型，也可以隐式的在变量声明、赋值或作为表达式操作元时隐式的指定具体类型。如果常量的值和他的类型不匹配，会报错。</p><p>无类型常量由一个默认的类型，这个类型会根据使用常量时的上下文进行隐式转换。例如：短变量声明 <code>i := 0</code> 没有指定 i 的类型。无类型常量的默认类型可以是：<code>bool</code>，<code>rune</code>，<code>int</code>，<code>float64</code>，<code>complex128</code> 或者 <code>string</code>，具体选择哪种类型由常量的值决定。</p><p>实现限制：虽然数字常量在 Go 中是任意精度，不过编译器在实现时会在内部限制精度。这意味着每个编译器实现都要：</p><ul><li><p>至少保证整形常量有 256 位</p></li><li><p>浮点数常量（包括复数常量）都要保证至少 256 位的主体部分和至少 16 位的有符号指数部分</p></li><li><p>如果不能表示给定整数的精度抛出错误</p></li><li><p>如果浮点数或复数溢出抛出错误</p></li><li><p>如果由于精度限制不能表示浮点数或者复数进行舍入</p></li></ul><p>这些要求同时作用于字面量常量额和常量表达式的结果。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量是一个用来储存值的位置。根据不同的变量类型，可以保存不同的值。</p><p>变量声明，函数参数和返回值，声明的函数签名，函数字面值都会为命名变量预留储存空间。调用内置的  <code>new</code>  函数或获取复合字面值的地址都会在运行时为变量分配存储空间。这种匿名变量是通过（可能是隐式的）指针间接引用的。</p><p>像数组，切片和结构体类型的变量，它们内部都包含很多元素或字段，而且这些元素和字段都可以直接被访问。数组和切片中的每个元素的行为和单独的变量基本相同。</p><p>变量的静态类型可以通过变量声明、提供给 <code>new</code> 的类型、复合字面值、结构体变量声明的元素类型以上几种方式确定。通过new或者类型初始化。接口类型的变量也有一个明确的动态类型，这个动态类型是在运行时赋值给变量的具体值类型（特例：预声明的 nil 是无类型的）。动态类型在程序的执行过程中可能并不相同，但是接口变量的值是可以分配给相同静态类型的变量。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">var x interface{}  // x 的静态类型为 interface{} 值为 nilvar v *T           // v 的静态类型为 *T 值为 nilx = 42             // x 的动态类型为 int 值为 42x = v              // x 动态类型为 *T 值为 (*T)(nil)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在表达式中使用变量可以取出变量的值；这个值就是变量最近一次被赋予的值。如果没有对变量赋过值，那么他的值是该类型的零值。</p><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>类型是一个集合，集合包括值和针对值的操作&amp;方法。一个类型可以使用类型名来表示。类型有多种表现形式：如果存在类型名，可以使用类型名表示，或者也可以使用根据已有类型组合成的类型字面值。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">Type      = TypeName | TypeLit | "(" Type ")" .TypeName  = identifier | QualifiedIdent .TypeLit   = ArrayType | StructType | PointerType | FunctionType | InterfaceType |    SliceType | MapType | ChannelType .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Go 已经预先声明了某些类型的名称。并引入了类型声明。复合类型（数组、结构体、指针、函数、接口、切片、map、channel）可以使用他们的类型字面值。</p><p>每个类型T都有一个底层类型。如果T是预定义类型或者类型字面值。那么底层类型就是他自身。否则，T的底层类型就是它再类型声明时引用到的类型。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">type (A1 = stringA2 = A1)type (B1 stringB2 B1B3 []B1B4 B3)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>string</code>，<code>A1</code>，<code>A2</code>，<code>B1</code>，<code>B2</code> 的底层类型是 <code>string</code>。<code>[]B1</code>，<code>B3</code>，<code>B4</code> 的下游类型是[]B1。</p><h4 id="方法集"><a href="#方法集" class="headerlink" title="方法集"></a>方法集</h4><p>类型可能会有一个与之关联的方法集。接口类型的方法集就可以使用自身表示。对于其他类型，类型 T 的方法集由所有接收者类型为 T 的方法组成。而对应指针类型 *T 的方法集由所有接收者类型为 T 或 *T 的方法组成。如果是结构体类型且含有嵌入字段，那么方法集中可能还会包含更多的方法，具体请看结构体类型章节。其他类型的方法集都为空。方法集中的每个方法都有唯一且不为空的方法名。</p><p>类型的方法集用来确定类型实现的接口和以类型作为接收者能够调用的方法。</p><h4 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h4><p>布尔类型表示预定义常量 <code>true</code> 和 <code>false</code> 表示布尔真实值的集合。预定义的布尔类型为 <code>bool</code>；它是通过类型声明创建的。</p><h4 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h4><p>一个数字类型相当于整型和浮点型的所有值的集合。预定义的数字类型包括：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">uint8       8 位无符号整数集合 (0 to 255)uint16      16 位无符号整数集合 (0 to 65535)uint32      32 位无符号整数集合 (0 to 4294967295)uint64      64 位无符号整数集合 (0 to 18446744073709551615)int8        8 位有符号整数集合 (-128 to 127)int16       16 位有符号整数集合 (-32768 to 32767)int32       32 位有符号整数集合 (-2147483648 to 2147483647)int64       64 位有符号整数集合 (-9223372036854775808 to 9223372036854775807)float32     IEEE-754 32 位浮点数集合float64     IEEE-754 64 位浮点数集合complex64   实部虚部都为 float32 的复数集合complex128  实部虚部都为 float64 的复数集合byte        uint8 的别名rune        int32 的别名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>n 位整数的值具有 n 比特的宽度并用补码表示。</p><p>以下几种预定义类型由具体平台实现指定长度：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">uint     32 或 64 位int      和 uint 位数相同uintptr  能够容纳指针值的无符号整数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>为了避免移植性问题，除了被 uint8 的别名 byte 和 int32 的别名 rune，其他所有的数字类型都是通过类型声明定义。当在表达式中使用不同的数字类型需要进行类型转换。例如：int32 和 int 不是相同的类型，即使他们在指定的平台上是相等的。</p><h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><p>字符串类型表示字符串的值类型。字符串的值是一个字节序列（有可能为空）。字符串一旦创建就无法修改它的值。预定义的字符串类型是 <code>string</code>，它是通过类型声明定义的。</p><p>可以使用内置函数 <code>len</code> 获取字符串长度。如果字符串是常量那么它的长度在编译时也为常量。可以通过数字下标 0～len(s)-1 访问字符串字节。获取字符串的地址是非法操作；如果 <code>s[i]</code> 是字符串的第 i 个字节，那么 <code>&amp;s[i]</code> 是无效的。</p><h4 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h4><p>数组是一定数量的单一类型元素序列，而这个单一类型叫做元素类型。元素的个数表示元素的长度，它永远不是负数。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">ArrayType   = "[" ArrayLength "]" ElementType .ArrayLength = Expression .ElementType = Type .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>长度是数组类型的一部分；它是一个类型为 int 的非负常量。可以用内置函数 <code>len</code> 获取数组的长度。元素可以通过下标 <code>0～len(a)-1</code> 访问。数组一般都是一维的，不过也可以是多维的。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">[32]byte[2*N] struct { x, y int32 }[1000]*float64[3][5]int[2][2][2]float64  // same as [2]([2]([2]float64))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="切片类型"><a href="#切片类型" class="headerlink" title="切片类型"></a>切片类型</h4><p>切片描述了底层数组的一个连续片段并提供对连续片段内元素的访问。切片类型表示元素类型的数组的所有切片的集合。没有被初始化的切片用 nil 表示。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">SliceType = "[" "]" ElementType .<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>与数组一样，切片的可以使用索引访问并且有长度，切片的长度可以通过内置的 <code>len</code> 函数获取；与数组不同的是它的长度在运行时是可以变化的。我们可以通过下标 <code>0～len(s)-1</code> 来访问切片内的元素。切片的索引可能会小于相同元素再底层数组的索引。</p><p>切片一旦初始化，那么就有一个与之对应的底层数组保存切片中的元素。切片和底层的数组还有其他指向该数组的切片共享相同的储存空间；而不同的数组总是有着不同的存储空间。</p><p>切片的底层数组可能会延伸到切片末尾以外，切片的容积等于切片现在的长度加上数组中切片还没使用的长度；可以从原始切片中切出一个长度与容量相等的切片。切片的容量可以通过内置的 <code>cap(a)</code> 函数来获取。可以通过函数<code>make</code>来创建一个T类型的新切片。</p><p>使用内置函数 <code>make</code> 可以出实话给定元素类型 T 的切片。<code>make</code> 函数接收三个参数：切片类型、切片长度、切片容积，其中切片容积是可选参数。<code>make</code> 创建的切片会在底层分配一个切片所引用的新数组。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">make([]T, length, capacity)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>make</code> 的作用就是创建新数组并切分它，所以下面两种写法是等价的：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">make([]int, 50, 100)new([100]int)[0:50]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>与数组相同，切片一般是一维的，不过也可以复合成多维。数组中的数组都必须是相同的长度，但是切片中的切片长度是动态变化的，不过切片中的切片需要单独初始化。</p><h4 id="结构体类型"><a href="#结构体类型" class="headerlink" title="结构体类型"></a>结构体类型</h4><p>结构体是一个命名元素序列，命名元素也叫做字段，每个字段都对应一个名称和类型，字段的名字可以是显式指定的（标识符列表）也可以是隐式的（嵌入字段）。在结构体中非空字段具有唯一性。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">StructType    = "struct" "{" { FieldDecl ";" } "}" .FieldDecl     = (IdentifierList Type | EmbeddedField) [ Tag ] .EmbeddedField = [ "*" ] TypeName .Tag           = string_lit .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">// 空结构体.struct {}// 6个字段的结构体.struct {x, y intu float32_ float32  // paddingA *[]intF func()}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个指定了类型而没有指定名称的字段叫做嵌入字段，嵌入字段必须指定类型名 T 或指向非接口类型的指针类型 *T，其中 T 不能为指针类型。或者一个非接口类型的指针。并且T本身不能为指针类型。这种情况下会把类型名作为字段的名字。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">// 一个包含 4 个嵌入字段 T1, *T2, P.T3 和 *P.T4 的结构体struct {T1        // 字段名为 T1*T2       // 字段名为 T2P.T3      // 字段名为 T3*P.T4     // 字段名为 T4x, y int  // 字段名为 x 和 y}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以下声明是错误的因为字段名称必须唯一。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">struct {T     // 嵌入字段 *T 与 *P.T 冲突*T    // 嵌入字段 T 与 *P.T 冲突*P.T  // 嵌入字段 T 与 *T 冲突}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果 <code>x.f</code> 是表示该字段或方法 <code>f</code> 的合法选择器，则会调用结构 <code>x</code> 中嵌入字段的字段或方法 <code>f</code>。</p><p>从嵌入字段组合来的字段与结构体原来的字段行为基本相同，只是不能在结构体的复合字面值中直接使用。</p><p>给定一个结构体 S 和一个类型 T，依据以下规则生成组合后的方法集：</p><ul><li>如果 S 包含嵌入字段 T，则 S 和 *S 的方法集包括接收者为 T 的方法集，而 *S 包括 接收者为 *T 的方法集。</li><li>如果 S 包含字段 <em>T。那么S和</em>S均包含接收者为 T 和 *T 的所有方法集。</li></ul><p>声明字段时可以给该字段添加一个字符串的 tag。这个 tag 将会成为它所对应字段的一个属性。空 tag 和缺省 tag 是相同的。tag 的值可以通过反射的接口获取，可以作为类型结构体的类型定义的一部分，也可以忽略。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">struct {x, y float64 ""  // 空 tag 和缺省 tag 相同name string  "any string is permitted as a tag"_    [4]byte "ceci n'est pas un champ de structure"}// 结构体对应一个 TimeStamp 的 protocol buffer.// tag 字符串中定义了 protocol buffer 字段对应的数字;// 一般使用 reflect 包读取他们.struct {microsec  uint64 `protobuf:"1"`serverIP6 uint64 `protobuf:"2"`}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h4><p>指针类型表示所有指向给定类型变量的指针集合。这个指定的类型叫做指针的基础类型。没有初始化的指针值为nil。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">PointerType = "*" BaseType .BaseType    = Type .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">*Point*[4]int<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h4><p>函数类型可以表示所有具有相同参数类型和返回值类型的函数。未初始化的函数类型值为 nil。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">FunctionType   = "func" Signature .Signature      = Parameters [ Result ] .Result         = Parameters | Type .Parameters     = "(" [ ParameterList [ "," ] ] ")" .ParameterList  = ParameterDecl { "," ParameterDecl } .ParameterDecl  = [ IdentifierList ] [ "..." ] Type .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在参数和返回值列表中，标识符列表必须同时存在或缺省。如果存在，那么每个名字都表示指定类型的一个参数/返回值，这些标识符必须非空并且不能重复。如果缺省，指定类型的参数/返回值使用对应的类型表示。参数列表和返回值列表一般都是需要加括号，不过在只有一个缺省返回值时，它可以不使用括号。</p><p>函数的最后一个参数可以添加前缀 <code>...</code>。包含这种参数的函数叫做变参函数，它可以接收零个或多个参数。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func()func(x int) intfunc(a, _ int, z float32) boolfunc(a, b int, z float32) (bool)func(prefix string, values ...int)func(a, b int, z float64, opt ...interface{}) (success bool)func(int, int, float64) (float64, *[]int)func(n int) func(p *T)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a>接口类型</h4><p>接口类型指定了一个方法集。一个接口类型变量可以保存任何方法集是该接口超集的类型。我们可以认为类型实现了接口。没有初始化的接口类型值为 nil。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">InterfaceType      = "interface" "{" { MethodSpec ";" } "}" .MethodSpec         = MethodName Signature | InterfaceTypeName .MethodName         = identifier .InterfaceTypeName  = TypeName .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在接口类型的方法集中，每个方法的名称必须是非空且唯一。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">// A simple File interfaceinterface {Read(b Buffer) boolWrite(b Buffer) boolClose()}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接口可以由多个类型实现，例如：类型 <code>S1</code> 和类型 <code>S2</code> 都有以下方法集：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func (p T) Read(b Buffer) bool { return … }func (p T) Write(b Buffer) bool { return … }func (p T) Close() { … }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>（这里的类型 T 可以表示 <code>S1</code> 也可以表示 <code>S2</code> ） <code>S1</code> 和 <code>S2</code> 都实现了接口 <code>File</code>，而不用管类型是否还有其他方法。</p><p>一个类型实现了任何方法集的为其子集的接口。因此它可能实现了多个不同接口。例如：所有的类型都实现了空接口：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">interface{}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>与之相似，思考下面这个定义为 <code>Locker</code> 的接口：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">type Locker interface {Lock()Unlock()}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果 <code>S1</code> 和 <code>S2</code> 也实现了它：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func (p T) Lock() { … }func (p T) Unlock() { … }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>那它们就实现了两个接口 <code>Locker</code> 和 <code>File</code>。</p><p>一个接口 T 可以使用另一个接口 E 来指定方法。这种方式叫做将接口 E 嵌入进接口 T。它把 E 中所有的方法（包括导出和未导出的方法）全部添加进接口 T。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">type ReadWriter interface {Read(b Buffer) boolWrite(b Buffer) bool}type File interface {ReadWriter  // 与添加 ReadWriter 接口中的方法是等价的Locker      // 与添加 Locker 接口中的方法是等价的 Close()}type LockedFile interface {LockerFile        // 无效: Lock, Unlock 不是唯一的Lock()      // 无效: Lock 不是唯一的}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接口 T 不能递归的嵌入进自己或已经嵌入过它的接口。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">// 无效: Bad 不能嵌入它自己type Bad interface {Bad}// 无效: Bad1 不能嵌入已经引用它的 Bad2type Bad1 interface {Bad2}type Bad2 interface {Bad1}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Map类型"><a href="#Map类型" class="headerlink" title="Map类型"></a>Map类型</h4><p>map 类型是一种以唯一值作为键的无序集合。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">MapType     = "map" "[" KeyType "]" ElementType .KeyType     = Type .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>map的键类型必须能使用比较运算符 <code>==</code> 和 <code>!=</code> 进行比较。因此它的键类型不能是函数，map，或者切片。如果键是接口类型，那么比较运算符必须能比较他的动态值。如果不能会抛出一个运行时错误。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">map[string]intmap[*T]struct{ x, y float64 }map[string]interface{}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>map中元素的个数叫做它的长度。对于一个map <code>m</code>。它的长度可以通过内置函数 <code>len</code> 获得，而且它的长度可能再运行时发生变化。map 可以再运行时添加和取回元素，页可以使用内置函数 <code>delete</code>移除元素。</p><p>可以使用内置函数 <code>make</code> 初始化一个新的且为空的 map。它能指定 map 的类型和预留的空间：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">make(map[string]int)make(map[string]int, 100)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>map 的预留空间不会固定住 map 的长度；它可以通过添加一定数量的元素来增加自己的长度（nil map 不能添加元素）。nil map 和空 map 是相等的，只是 nil map 不能添加元素。</p><h4 id="Channel类型"><a href="#Channel类型" class="headerlink" title="Channel类型"></a>Channel类型</h4><p>channel提供一种手段在并发执行的函数间发送和接收指定类型的值。没有初始化的 channel 是nil。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">ChannelType = ( "chan" | "chan" "&lt;-" | "&lt;-" "chan" ) ElementType .<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>操作符 <code>&lt;-</code> 可以指定 channel 的数据流动方向。如果没有指定方向，channel 默认是双向的。channel 可以通过转换和赋值来限制只读和只写。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">chan T          // 可以接收和发送 T 类型的数据chan&lt;- float64  // 只能发送 float64 类型的值&lt;-chan int      // 只能接收<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>&lt;-</code> 与最左侧的 <code>chan</code> 关联：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">chan&lt;- chan int    // 等价于 chan&lt;- (chan int)chan&lt;- &lt;-chan int  // 等价于 chan&lt;- (&lt;-chan int)&lt;-chan &lt;-chan int  // 等价于 &lt;-chan (&lt;-chan int)chan (&lt;-chan int)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可以通过内置的 <code>make</code> 函数初始化 channel。<code>make</code> 函数可以指定channel的类型和容量。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">make(chan int, 100)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>容量是设置了最大能缓存元素的数量。如果没有设置容量或值为 0，channel 就是没有缓存的，这时只有当发送者和接收者都准备好后才会传输数据。而带缓存的 channel 在缓存没有满的时候依然可以成功发送数据，当缓存不为空的时候可以成功接收到数据，值为 nil 的 channel 不能传输数据。</p><p>可以通过内置函数 <code>close</code> 关闭 channel。在接收端的第二个返回值可以用来提示接收者在关闭的 channel 是否还包含数据。</p><p>channel 可以在发送语句，接收操作中使用。可以不考虑同步性直接在多个 goroutine 中对 channel 调用内置函数 <code>len</code> 和 <code>cap</code> 。channel 的行为和 FIFO 队列相同。举个例子，一个 goruntine 发送数据，另一个 goruntine 接收他们，接收数据的顺序和发送数据的顺序是相同的。</p><h2 id="类型的属性和值"><a href="#类型的属性和值" class="headerlink" title="类型的属性和值"></a>类型的属性和值</h2><h4 id="类型标识"><a href="#类型标识" class="headerlink" title="类型标识"></a>类型标识</h4><p>两个类型可能相同也可能不同。</p><p>定义的类型都是不同类型。如果两个类型的底层类型在结构上是相同的，那它们也是相等的。总的来说：</p><ul><li><p>2 个数组的长度和元素类型相同，那么它们就是相同类型。</p></li><li><p>如果两个切片的元素类型相同那么它们就是相同类型。</p></li><li><p>如果两个结构体字段顺序相同，并且字段名称、字段类型和 tag 都相同那么它们就是相等的。非导出字段的字段名在不同的包中总是不同的。</p></li><li><p>如果两个指针的基础类型相同那么他们具有相同类型。</p></li><li><p>如果两个函数具有相同的参数和返回值列表，并且他们的类型相同那么他们就是相同的，参数的名称不一定要相同。</p></li><li><p>如果两个接口的方法集完全相同（方法的顺序）。</p></li><li><p>如果两个 map 类型的键类型和值类型相同那它们就是相等的。</p></li><li><p>如果两个 channel 类型包含的对象类型和 channel 的方向都是相同的那它们就是相同的。</p></li></ul><p>给出下列声明：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">type (A0 = []stringA1 = A0A2 = struct{ a, b int }A3 = intA4 = func(A3, float64) *A0A5 = func(x int, _ float64) *[]string)type (B0 A0B1 []stringB2 struct{ a, b int }B3 struct{ a, c int }B4 func(int, float64) *B0B5 func(x int, y float64) *A1)typeC0 = B0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这些类型是相等的：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">A0, A1, and []stringA2 and struct{ a, b int }A3 and intA4, func(int, float64) *[]string, and A5B0, B0, and C0[]int and []intstruct{ a, b *T5 } and struct{ a, b *T5 }func(x int, y float64) *[]string, func(int, float64) (result *[]string), and A5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>B0 和 B1 不是一种类型因为它们是通过类型定义方式分别定义的；<code>func(int, float64) *B0</code> 和 <code>func(x int, y float64) *[]string</code> 是不同的，因为 B0 和 []string 不是相同类型。</p><h4 id="可分配性"><a href="#可分配性" class="headerlink" title="可分配性"></a>可分配性</h4><p>在以下情况下，可以将 x 分配给类型为 T 的变量（把 x 分配给 T）：</p><ul><li><p>x 的类型为 T</p></li><li><p>x 的类型 V 和 T 有相同的底层类型并且类型 T 或 V 至少一个定义的类型</p></li><li><p>T 是一个接口类型并且 x 实现了 T</p></li><li><p>x 是一个 channel，并且 T 是channel类型，类型V和类型T有相同的元素类型，并且 2 种类型至少有一种不是定义的类型</p></li><li><p>x 等于 nil 并且 T 是一个指针，函数，切片，map，channel 或接口类型</p></li><li><p>x 是一个可以表示 T 类型值的无类型常量</p></li></ul><h4 id="代表性"><a href="#代表性" class="headerlink" title="代表性"></a>代表性</h4><p>满足以下条件时可以用 T 类型的值表示常量 x：</p><ul><li><p>T 值的集合包括 x</p></li><li><p>T 是浮点型，而 x 在没有溢出的情况下能够近似成 T 类型。近似规则使用 <code>IEEE 754 round-to-even</code>，负零和无符号的零相同。需要注意的是，常量的值不会为负零，NaN，或无限值。</p></li><li><p>T 为复数类型，并且 x 的 <code>real(x)</code> 和 <code>imag(x)</code> 部分由复数类型对应的浮点类型（<code>float32</code> 或 <code>float64</code> ）组成。</p></li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go">x                   T           x 可以表示 T 的值，因为：'a'                 byte        97 在 byte 类型值的集合中97                  rune        rune 是 int32 的别名，97 在 32 位整型值的集合中"foo"               string      "foo" 在字符串值的集合中1024                int16       1024 在 16 位整型值的集合中42.0                byte        42 在 8 位无符号整型值的集合中1e10                uint64      10000000000 在 64 位无符号整型值的集合中2.718281828459045   float32     2.718281828459045 的近似值 2.7182817 在 float32 类型值的集合中-1e-1000            float64     -1e-1000 的近视值 IEEE -0.0，等于 0 0i                  int         0 是整型值(42 + 0i)           float32     42.0 (0 虚部) 在 float32 类型值的集合中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">x                   T           x 不能表示 T 的值，因为：0                   bool        0 不在布尔值的集合中'a'                 string      'a' 是 rune 类型, 它不在字符串类型的值集合中1024                byte        1024 不在 8 位无符号整型值的集合中-1                  uint16      -1 不在 16 位无符号整型值的集合中1.1                 int         1.1 不是整型值42i                 float32     (0 + 42i) 不在 float32 类型值的集合中1e1000              float64     1e1000 取近似值时会溢出成 IEEE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>代码块是用大括号括起来的声明和语句。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">Block = "{" StatementList "}" .StatementList = { Statement ";" } .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>除了源码中显式的代码块，也有一些隐式的代码块。</p><ul><li><p>包含所有的Go代码的全局代码块。</p></li><li><p>包含所有包的代码的包代码块。</p></li><li><p>包含文件内的所有代码的文件代码块。</p></li><li><p>每个 if，switch和 for 的范围都会形成隐式的块。</p></li><li><p>每个 switch 和 select 条件都有自己的代码块。</p></li></ul><p>代码块可以嵌套并且影响作用域。</p><h2 id="声明和作用域"><a href="#声明和作用域" class="headerlink" title="声明和作用域"></a>声明和作用域</h2><p>一段声明可以给常量，类型，变量，函数，标签，和包绑定标识符。程序中每个标识符都需要声明。相同标识符不能在同一个代码块中声明2次。并且相同标识符不能同时在文件和 package 代码块中声明。</p><p>空标识符可以和其他标识符一样在声明中使用。不过它不绑定标识符，等于没有声明。在 package 代码块中 <code>init</code> 标识符只能用做 <code>init</code> 函数的标识符，就像空标识符一样，它不会引入新的绑定。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">Declaration   = ConstDecl | TypeDecl | VarDecl .TopLevelDecl  = Declaration | FunctionDecl | MethodDecl .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>声明过的标识符的作用域就是声明标识符所在的作用域。</p><p>go使用块来规定词汇的方位：</p><ul><li><p>预定义的标识符具有全局作用域。</p></li><li><p>所有定义的顶级标识符具有包作用域。</p></li><li><p>import进来的包的名字标识符具有文件作用域。</p></li><li><p>方法的接收者，函数参数，返回值变量具有函数作用域。</p></li><li><p>函数内定义的参量和变量标识符的作用域是标识符被声明到容纳他的块结束。</p></li></ul><p>一个代码块中声明的标识符可以在它内部的代码块中重新声明。在内部代码块的作用域中标识符表示在内部代码块中声明的实体。</p><p>pakcage 语句不属于声明。包名不会出现在任何的作用域中。它的作用只是用来标识属于相同包的多个文件并在导入时指定默认包名。</p><h4 id="标签的作用域"><a href="#标签的作用域" class="headerlink" title="标签的作用域"></a>标签的作用域</h4><p>可以使用标签语句来声明标签，并且可以在 <code>break</code>，<code>continue</code>，<code>goto</code> 语法中使用。如果只声明但没有使用标签时非法的。标签的作用域只有定义时的函数体，早递归函数体中没有作用。</p><h4 id="空标识符"><a href="#空标识符" class="headerlink" title="空标识符"></a>空标识符</h4><p>空标识符使用下划线 <code>_</code> 代表。与一般的非空标识符不同，它作为匿名标识符在声明，运算元和赋值语句中都有特殊含义。</p><h4 id="预定义的标识符"><a href="#预定义的标识符" class="headerlink" title="预定义的标识符"></a>预定义的标识符</h4><p>以下标识符已经在全局作用域中预先声明：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">Types:bool byte complex64 complex128 error float32 float64int int8 int16 int32 int64 rune stringuint uint8 uint16 uint32 uint64 uintptrConstants:true false iotaZero value:nilFunctions:append cap close complex copy delete imag lenmake new panic print println real recover<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="导出标识符"><a href="#导出标识符" class="headerlink" title="导出标识符"></a>导出标识符</h4><p>标识符可以导出供其他包使用。在以下两种情况同时满足时标识符是导出的：</p><ul><li>标识符的首字母是大写（Unicode 的 <code>Lu</code> 类）</li><li>标识符声明在包作用域或者它是字段名/方法名。</li></ul><p>其他任何标识符都不是导出的。</p><h4 id="标识符的唯一性"><a href="#标识符的唯一性" class="headerlink" title="标识符的唯一性"></a>标识符的唯一性</h4><p>给定一个标识符集合，一个标识符与集合中的每个标识符都不相同，那就认为这个标识符是唯一的。假设有两个标识符，如果它们的拼写不同，或者它们在不同的包中并没有导出，那它们就是不同标识符。相反，其他情况下都认为标识符是相同的。</p><h4 id="常量声明"><a href="#常量声明" class="headerlink" title="常量声明"></a>常量声明</h4><p>常量声明使用常量表达式绑定一系列标识符。标识符的数量必须等于表达式的数量。左侧第 n 个标识符绑定右侧第 n 个表达式的值。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">ConstDecl      = "const" ( ConstSpec | "(" { ConstSpec ";" } ")" ) .ConstSpec      = IdentifierList [ [ Type ] "=" ExpressionList ] .IdentifierList = identifier { "," identifier } .ExpressionList = Expression { "," Expression } .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果给定类型，常量会指定类型，并且表达式的值必须能对这个类型进行赋值。</p><p>如果没有给定类型。常量会转换成相应的表达式类型。如果表达式的值是无类型常量，那么声明的常量也是无类型的，并且常量的标识符代表常量的值。例如：即使小数部分是 0，只要表达式是浮点数字面值，常量标识符也表示为浮点数常量。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">const Pi float64 = 3.14159265358979323846const zero = 0.0         // 无类型浮点数常量const (size int64 = 1024eof        = -1  // 无类型整型常量)const a, b, c = 3, 4, "foo"  // a = 3, b = 4, c = "foo", 无类型整型和字符串常量const u, v float32 = 0, 3    // u = 0.0, v = 3.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>括号内的常量声明列表的表达式除了第一个必须声明其他表达式可以不写。空的表达式列表的值和类型都和前面的非空表达式相同。缺省的表达式列表等价于重复之前的表达式。标识符的数量必须等于表达式的数量。<code>iota</code>常量生成器是一个可以快速生成序列值的机制。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">const (Sunday = iotaMondayTuesdayWednesdayThursdayFridayPartydaynumberOfDays  // 非导出常量)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Iota"><a href="#Iota" class="headerlink" title="Iota"></a>Iota</h4><p>在常量声明中，预定义的标识符 <code>iota</code> 表示连续的无类型整型常量。它的值为常量声明中每个常量定义的位置（从零开始）。它能够用来生成一个关联常量集合：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">const ( // iota is reset to 0c0 = iota  // c0 == 0c1 = iota  // c1 == 1c2 = iota  // c2 == 2)const ( // iota is reset to 0a = 1 &lt;&lt; iota  // a == 1b = 1 &lt;&lt; iota  // b == 2c = 3          // c == 3  (没有使用 iota 不过它的值依然递增)d = 1 &lt;&lt; iota  // d == 8)const ( // iota is reset to 0u         = iota * 42  // u == 0     (无类型整型常量)v float64 = iota * 42  // v == 42.0  (float64 类型常量)w         = iota * 42  // w == 84    (无类型整型常量))const x = iota  // x == 0  (iota 被重置)const y = iota  // y == 0  (iota 被重置)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>根据定义，在同一个常量定义中多次使用 <code>iota</code> 会得到相同的值：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">const (bit0, mask0 = 1 &lt;&lt; iota, 1&lt;&lt;iota - 1  // bit0 == 1, mask0 == 0  (iota == 0)bit1, mask1                           // bit1 == 2, mask1 == 1  (iota == 1)_, _                                  //                        (iota == 2, unused)bit3, mask3                           // bit3 == 8, mask3 == 7  (iota == 3))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后一个例子利用了最后一个非空表达式列表的隐式重复。</p><h4 id="类型声明"><a href="#类型声明" class="headerlink" title="类型声明"></a>类型声明</h4><p>类型声明为类型绑定一个标识符。类型声明有2种方式：类型声明和别名声明。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">TypeDecl = "type" ( TypeSpec | "(" { TypeSpec ";" } ")" ) .TypeSpec = AliasDecl | TypeDef .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="Alias声明"><a href="#Alias声明" class="headerlink" title="Alias声明"></a>Alias声明</h5><p>别名声明给指定类型绑定一个标识符名称。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">AliasDecl = identifier "=" Type .<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在标识符作用域内，它作为类型的别名。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">type (nodeList = []*Node  // nodeList 和 []*Node 是相同类型Polar    = polar    // Polar 和 polar 表示相同类型)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="Type-定义"><a href="#Type-定义" class="headerlink" title="Type 定义"></a>Type 定义</h5><p>类型定义会创建一个新类型并绑定一个标识符，新类型与给定类型具有相同的底层类型和操作。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">TypeDef = identifier Type .<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个类型叫做定义类型，它和其他所有类型都不相同，包括创建它的类型。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">type (Point struct{ x, y float64 }  // Point 和 struct{ x, y float64 } 是不同类型polar Point                   // polar 和 Point 表示不同类型)type TreeNode struct {left, right *TreeNodevalue *Comparable}type Block interface {BlockSize() intEncrypt(src, dst []byte)Decrypt(src, dst []byte)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>定义类型可以关联该类型的方法。它不会继承原来类型的任何方法。但是接口类型的方法集和类型的结构没有改变。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">// Mutex 是一个拥有 Lock 和 Unlock 两个方法的数据类型。type Mutex struct         { /* Mutex fields */ }func (m *Mutex) Lock()    { /* Lock implementation */ }func (m *Mutex) Unlock()  { /* Unlock implementation */ }// NewMutex 与 Mutex 结构相同不过方法集为空。type NewMutex Mutex// PtrMutex 的底层类型 *Mutex 的方法集没有改变，// 但是 PtrMutex 的方法集为空。type PtrMutex *Mutex// *PrintableMutex 包含嵌入字段 Mutex 的 Lock 和 Unlock 方法。type PrintableMutex struct {Mutex}// MyBlock 是与 Block 有相同方法集的接口类型type MyBlock Block<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类型定义可以定义方法集不同的布尔值、数字和字符串类型：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">type TimeZone intconst (EST TimeZone = -(5 + iota)CSTMSTPST)func (tz TimeZone) String() string {return fmt.Sprintf("GMT%+dh", tz)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h4><p>变量声明可以创建一个或多个变量，并绑定对应的标识符、指定类型和初始值。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">VarDecl     = "var" ( VarSpec | "(" { VarSpec ";" } ")" ) .VarSpec     = IdentifierList ( Type [ "=" ExpressionList ] | "=" ExpressionList ) .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">var i intvar U, V, W float64var k = 0var x, y float32 = -1, -2var (i       intu, v, s = 2.0, 3.0, "bar")var re, im = complexSqrt(-1)var _, found = entries[name]  // map lookup; only interested in "found"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果给定一个表达式列表。变量会根据赋值规则使用表达式进行初始化。否则，每个变量都会初始化成变量类型的零值。</p><p>如果指定类型，变量会为指定类型。如果没有指定类型，变量会使用分配的初始值类型。如果初始值为无类型常量，它会转换成初始值的默认类型。如果是一个无类型布尔值，那么变量的类型就是 <code>bool</code>。值 <code>nil</code> 不能给没有指定类型的变量赋值。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">var d = math.Sin(0.5)  // d is float64var i = 42             // i is intvar t, ok = x.(T)      // t is T, ok is boolvar n = nil            // illegal<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>实现的限制：在函数体内声明的变量如果没有使用过编译器需要报错。</p><h4 id="短变量声明"><a href="#短变量声明" class="headerlink" title="短变量声明"></a>短变量声明</h4><p>短变量声明的语法:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">ShortVarDecl = IdentifierList ":=" ExpressionList .<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>它比正常使用初始化表达式进行变量声明的方式要短，而且不指定类型：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">"var" IdentifierList = ExpressionList .<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">i, j := 0, 10f := func() int { return 7 }ch := make(chan int)r, w := os.Pipe(fd)  // os.Pipe() 返回两个值_, y, _ := coord(p)  // coord() 返回三个值，我们只关注 y<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>和常规变量声明不同，即使之前在相同代码块中声明过的变量，也可以在短变量重新声明相同类型的变量，并且保证至少会有一个新的非空变量。总之，只应该在多变量短声明的时候重新声明变量，重新声明并不会使用新的变量，而是给变量分配新值。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">field1, offset := nextField(str, 0)field2, offset := nextField(str, offset)  // 重新声明 offseta, a := 1, 2                              // 非法：声明了 a 两次并且没有新的变量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>短变量声明只能在函数中使用，例如在 <code>if</code>、<code>for</code>、<code>switch</code>语句的上下文中声明临时变量。</p><h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><p>函数声明为函数绑定标识符。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">FunctionDecl = "func" FunctionName Signature [ FunctionBody ] .FunctionName = identifier .FunctionBody = Block .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果函数指定了返回参数。函数体的语句必须以终止语句结束。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func IndexRune(s string, r rune) int {   for i, c := range s {   if c == r {   return i   }   }   // 无效：缺少 return 语句}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数声明可以没有函数体。这样的声明提供一个函数声明，并由其他外部实现，例如汇编脚本。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func min(x int, y int) int {if x &lt; y {return x}return y}func flushICache(begin, end uintptr)  // 由外部实现<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="方法声明"><a href="#方法声明" class="headerlink" title="方法声明"></a>方法声明</h4><p>方法是一个带接收者的函数，方法声明为方法绑定标识符作为方法名并指定方法对应的接收者类型。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">MethodDecl = "func" Receiver MethodName Signature [ FunctionBody ] .Receiver   = Parameters .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>接收者通过在方法增加一个额外的参数来指定。这个参数必须是一个非可变参数。它的类型必须是 T 或者 T 的指针（可能包含括号）。T 被称作接收者的基础类型；它不能是指针或接口类型，并且只能在同一个包中定义方法。声明后，我们认为方法绑定了基础类型，并且可以通过 T 或 *T 选择器访问方法名。</p><p>非空的接收者标识符在方法签名中必须是唯一的。如果接收者的值没有在该方法中使用，那么接收者标识符可以省略。函数和方法的参数也是一样。</p><p>对于一个基础类型。绑定的非空的方法名必须是唯一的。如果基础类型是一个结构体，非空的方法名也不能与结构体字段重复。</p><p>给定一个<code>Point</code>类型。声明：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func (p *Point) Length() float64 {return math.Sqrt(p.x * p.x + p.y * p.y)}func (p *Point) Scale(factor float64) {p.x *= factorp.y *= factor}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为类型 <code>*Point</code>绑定了2个方法 <code>Length</code> 和 <code>Scale</code>。</p><p>方法的类型就是以接收者作为第一个参数的函数类型，例如 <code>Scale</code> 方法：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func(p *Point, factor float64)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但是以这种方式声明的函数并不是方法。</p><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>表达式通过针对运算元使用运算符和函数来获取计算值。</p><h4 id="运算元"><a href="#运算元" class="headerlink" title="运算元"></a>运算元</h4><p>运算元代表表达式中的一个简单的。运算元可以是字面值，非空标识符。或括号表达式。</p><p>空标识符只能出现在赋值声明的左侧。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">Operand     = Literal | OperandName | MethodExpr | "(" Expression ")" .Literal     = BasicLit | CompositeLit | FunctionLit .BasicLit    = int_lit | float_lit | imaginary_lit | rune_lit | string_lit .OperandName = identifier | QualifiedIdent.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="修饰标识符"><a href="#修饰标识符" class="headerlink" title="修饰标识符"></a>修饰标识符</h4><p>修饰标识符是以包名作为前缀修饰的标识符。包名和标识符都不能为空。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">QualifiedIdent = PackageName "." identifier .<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修饰标识符可以用来访问不同包（需要先导入）中的标识符。标识符必须是导出的并在包级代码块声明才能够被访问。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">math.Sin// 表示 math 包中的 Sin 函数<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="复合字面值"><a href="#复合字面值" class="headerlink" title="复合字面值"></a>复合字面值</h4><p>复合字面值能为结构体、数组、切片和 map 初始化值。它每次只能创建一个值。字面值由一个字面值类型和使用括号括起来的元素列表组成。元素前也可以声明元素对应的键。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">CompositeLit  = LiteralType LiteralValue .LiteralType   = StructType | ArrayType | "[" "..." "]" ElementType |                SliceType | MapType | TypeName .LiteralValue  = "{" [ ElementList [ "," ] ] "}" .ElementList   = KeyedElement { "," KeyedElement } .KeyedElement  = [ Key ":" ] Element .Key           = FieldName | Expression | LiteralValue .FieldName     = identifier .Element       = Expression | LiteralValue .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>字面值类型的底层类型必须是一个结构体，数组，切片或 map 类型（如果没有指定类型名就会强制执行这个约束）。元素的类型和键都必须能够分配给相应的字段的元素和键类型；没有额外的类型转换。键可以表示结构体的字段名，切片和数组的索引，map 类型的键。对于 map 字面值，所有的元素都必须有键。如果相同字段名或常量值的键对应多个元素就会报错。如果 map 类型的键为非常量类型，请看求值顺序章节。</p><p>结构体字面值遵循以下规则：</p><ul><li><p>在结构体中，键必须是它的字段名。</p></li><li><p>不包含任何键的元素列表的顺序需要与结构体字段的声明顺序相同。</p></li><li><p>如果一个元素指定了键，那么所有的元素都必须指定键。</p></li><li><p>包含键的元素列表不需要指定结构体的每个字字段，缺省字段会使用字段类型的零值。</p></li><li><p>字面值可以不指定元素；这样的字面值等于该类型的零值。</p></li><li><p>指定非本包的非导出字段会报错。</p></li></ul><p>给定声明：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">type Point3D struct { x, y, z float64 }type Line struct { p, q Point3D }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>我们可以使用这种写法：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">origin := Point3D{}                            // Point3D 的零值line := Line{origin, Point3D{y: -4, z: 12.3}}  // line.q.x 的零值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>数组和切片遵循以下规则：</p><ul><li><p>每个元素都关联一个数字索引标记元素再数组中的位置。</p></li><li><p>给元素指定的键会作为它的索引。键必须是能够表示非负的 <code>int</code> 类型值的常量；如果是指定类型的常量，那么常量必须是整型。</p></li><li><p>元素没有指定键时会使用之前的索引加一。如果第一个元素没有指定键，它的索引为零。</p></li></ul><p>对复合字面值取址会生成指向由字面量初始化的变量的指针。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">var pointer *Point3D = &amp;Point3D{y: 1000}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>数组字面值需要在类型中指定数组的长度。如果提供的元素少于数组的长度，那么缺少元素的位置将会使用元素类型的零值替代。如果索引超过数组的长度会报错。<code>…</code> 表示数组的长度等于最大元素索引加一。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">buffer := [10]string{}             // len(buffer) == 10intSet := [6]int{1, 2, 3, 5}       // len(intSet) == 6days := [...]string{"Sat", "Sun"}  // len(days) == 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>切片字面值底层其实就是数组字面值。因此它的长度和容量都是元素的最大索引加一。切片字面值的格式为：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">[]T{x1, x2, … xn}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以在数组上进行切片操作从而获得切片：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">tmp := [n]T{x1, x2, … xn}tmp[0 : n]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在一个数组、切片或 map 类型 T 中。元素或者 map 的键可能有自己的字面值类型，如果字面值类型和元素或者键类型相同，那么对应的类型标识符可以省略。与之类似，如果元素或键的类型为 <code>*T</code>，那么它们的 <code>&amp;T</code> 也可以省略。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">[...]Point{{1.5, -3.5}, {0, 0}}     // same as [...]Point{Point{1.5, -3.5}, Point{0, 0}}[][]int{{1, 2, 3}, {4, 5}}          // same as [][]int{[]int{1, 2, 3}, []int{4, 5}}[][]Point{{{0, 1}, {1, 2}}}         // same as [][]Point{[]Point{Point{0, 1}, Point{1, 2}}}map[string]Point{"orig": {0, 0}}    // same as map[string]Point{"orig": Point{0, 0}}map[Point]string{{0, 0}: "orig"}    // same as map[Point]string{Point{0, 0}: "orig"}type PPoint *Point[2]*Point{{1.5, -3.5}, {}}          // same as [2]*Point{&amp;Point{1.5, -3.5}, &amp;Point{}}[2]PPoint{{1.5, -3.5}, {}}          // same as [2]PPoint{PPoint(&amp;Point{1.5, -3.5}), PPoint(&amp;Point{})}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当复合字面值使用字面值类型的类型名格式出现在 <code>if</code>、<code>for</code> 或 <code>switch</code> 语句的关键字和括号之间并且没有使用圆括号包裹的时候，会引发语法歧义。在这种特殊的情况下字面值的括号会被认为是语句的代码块。为了避免歧义，复合字面值必须用括号括起来。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">if x == (T{a,b,c}[i]) { … }if (x == T{a,b,c}[i]) { … }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>下面是合法的数组、切片和 map 的例子：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">// list of prime numbersprimes := []int{2, 3, 5, 7, 9, 2147483647}// vowels[ch] is true if ch is a vowelvowels := [128]bool{'a': true, 'e': true, 'i': true, 'o': true, 'u': true, 'y': true}// the array [10]float32{-1, 0, 0, 0, -0.1, -0.1, 0, 0, 0, -1}filter := [10]float32{-1, 4: -0.1, -0.1, 9: -1}// frequencies in Hz for equal-tempered scale (A4 = 440Hz)noteFrequency := map[string]float32{"C0": 16.35, "D0": 18.35, "E0": 20.60, "F0": 21.83,"G0": 24.50, "A0": 27.50, "B0": 30.87,}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="函数字面值"><a href="#函数字面值" class="headerlink" title="函数字面值"></a>函数字面值</h4><p>函数字面值表示一个匿名函数。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">FunctionLit = "func" Function .<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">func(a, b int, z float64) bool { return a*b &lt; int(z) }<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>函数字面值能分配给变量或直接调用。</p><p>函数字面值是一个闭包。它可以引用包裹函数中的变量，这些变量在包裹函数和函数字面值之间是共享的。并且它会一直存在直到生命周期结束。</p><h4 id="主要表达式"><a href="#主要表达式" class="headerlink" title="主要表达式"></a>主要表达式</h4><p>主要表达式是一元和二元表达式的运算元。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">PrimaryExpr =Operand |Conversion |PrimaryExpr Selector |PrimaryExpr Index |PrimaryExpr Slice |PrimaryExpr TypeAssertion |PrimaryExpr Arguments .Selector       = "." identifier .Index          = "[" Expression "]" .Slice          = "[" [ Expression ] ":" [ Expression ] "]" |                 "[" [ Expression ] ":" Expression ":" Expression "]" .TypeAssertion  = "." "(" Type ")" .Arguments      = "(" [ ( ExpressionList | Type [ "," ExpressionList ] ) [ "..." ] [ "," ] ] ")" .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">x2(s + ".txt")f(3.1415, true)Point{1, 2}m["foo"]s[i : j + 1]obj.colorf.p[i].x()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h4><p>对于一个 x 不是包名的主要表达式，选择器表达式：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">x.f<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>表示 x 的字段或方法 f（有时为 *x）。标识符 f 叫做（字段/方法）选择器。它不能是空标识符。选择器表达式的类型就是 f 的类型。如果 x 是包名。请参考修饰标识符。</p><p>选择器 f 可以表示类型 T 的方法或字段 f。也可以表示类型 T 的嵌入方法或字段 f。访问 f 所需穿过的嵌套层数叫做它在类型 T 中的深度。声明在 T 中的字段或方法的深度为 0。声明在 T 的嵌入字段 A 中的方法或字段的深度等于 f 在 A 中的深度加一。</p><p>选择器遵循以下原则：</p><ul><li><p>对于非指针/接口类型 T/*T 的值 x，x.f 表示第一层的方法/字段。如果在第一层没有对应的 f，选择器表达式就是非法的。</p></li><li><p>对于接口类型 I 的值 x，<code>x.f</code>表示动态值 x 的方法名 f。如果接口 I 的方法集中没有 f 方法，选择器就是非法的。</p></li><li><p>作为例外，如果 x 是一个指针类型并且 (*x).f 是合法的选择器表达式（只能表示字段，不能表示方法）。那么(*x).f 可以简写成 x.f。</p></li><li><p>在其他情况下，x.f 都是非法的。</p></li><li><p>如果x是指针类型，并且值为 nil，其中 f 为结构体字段。赋值或取值 x.f 会引起运行时恐慌。</p></li><li><p>如果x是接口类型，并且值为 nil。调用 x.f  会引起运行时恐慌。</p></li></ul><p>例如给定声明：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">type T0 struct {x int}func (*T0) M0()type T1 struct {y int}func (T1) M1()type T2 struct {z intT1*T0}func (*T2) M2()type Q *T2var t T2     // with t.T0 != nilvar p *T2    // with p != nil and (*p).T0 != nilvar q Q = p<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">t.z          // t.zt.y          // t.T1.yt.x          // (*t.T0).xp.z          // (*p).zp.y          // (*p).T1.yp.x          // (*(*p).T0).xq.x          // (*(*q).T0).x        (*q).x is a valid field selectorp.M0()       // ((*p).T0).M0()      M0 expects *T0 receiverp.M1()       // ((*p).T1).M1()      M1 expects T1 receiverp.M2()       // p.M2()              M2 expects *T2 receivert.M2()       // (&amp;t).M2()           M2 expects *T2 receiver, see section on Calls<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是下面这种方式是不合法的：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">q.M0()       // (*q).M0 is valid but not a field selector<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="方法表达式"><a href="#方法表达式" class="headerlink" title="方法表达式"></a>方法表达式</h4><p>如果 M 在类型 T 的方法集中。那么 T.M 就是能够正常调用的函数。使用与 M 相同的参数只是在参数列表的最前面增加了接收者参数。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">MethodExpr    = ReceiverType "." MethodName .ReceiverType  = TypeName | "(" "*" TypeName ")" | "(" ReceiverType ")" .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>假设结构体 T 有两个方法。接收者类型为 T 的 Mv 方法和接收者类型为 *T 的 Mp 方法：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">type T struct {a int}func (tv  T) Mv(a int) int         { return 0 }  // value receiverfunc (tp *T) Mp(f float32) float32 { return 1 }  // pointer receivervar t T<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>表达式</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">T.Mv<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将会生成一个等价于 Mv 方法只是第一个参数显式声明接受者的函数。它的签名为：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func(tv T, a int) int<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个函数能够通过接收者正常调用，以下5种方式是等价的：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">t.Mv(7)T.Mv(t, 7)(T).Mv(t, 7)f1 := T.Mv; f1(t, 7)f2 := (T).Mv; f2(t, 7)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与之类似：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">(*T).Mp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>生成表示 Mp 的函数签名：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func(tp *T, f float32) float32<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对于一个把值作为接收者的方法，我们可以显式的从指针接收者获得函数：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">(*T).Mv<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>生成表示 Mv 的函数签名：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func(tv *T, a int) int<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样的函数会通过接收者间接的创建一个值作为接收者传入底层方法中。方法内不能修改接收者的值，因为它的地址是在函数的调用栈里面。</p><p>最后一个例子。把值作为接收者函数当做指针作为接收者的方法是非法的，因为指针接收者的方法集中不包含值类型的方法集。</p><p>通过函数调用语法从方法中获取函数的值。接收者作为调用函数的第一个参数。给定  <code>f :=T.Mv</code>，f 作为<code>f(t,7)</code> 进行调用而不是 <code>t.f(7)</code>。想创建一个绑定接收者的函数可以使用函数字面值或者方法值。</p><p>在接口类型中定义函数获取函数值是合法的。最终的函数调用会使用接口类型作为接收者。</p><h4 id="方法值"><a href="#方法值" class="headerlink" title="方法值"></a>方法值</h4><p>如果表达式 x 拥有静态类型 T 并且 M 在类型 T 的方法集中。x.M 叫做方法值。方法值 <code>x.M</code> 是一个函数值，这个函数和 x.M 拥有相同的参数列表。表达式 x 在计算方法值时会被保存和计算，这个拷贝的副本会作为任何接下来调用的接收者。</p><p>类型 T 可能是接口类型也可能不是接口类型。</p><p>与方法表达式中讲过的一样，假设类型 T 有两个方法：接收者类型为 T 的 Mv 和接受者类型为 *T 的 Mp ：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">type T struct {a int}func (tv  T) Mv(a int) int         { return 0 }  // value receiverfunc (tp *T) Mp(f float32) float32 { return 1 }  // pointer receivervar t Tvar pt *Tfunc makeT() T<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>表达式：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">t.Mv<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>生成一个类型的函数值：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func(int) int<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以下两种调用是等价的：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">t.Mv(7)f := t.Mv; f(7)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>相似的，表达式：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">pt.Mp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>生成一个类型的函数值：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func(float32) float32<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>与选择器相同，使用指针调用以值作为接收者的非接口方法会自动将指针解引用：<code>pt.Mv</code> 等价于 <code>(*pt).Mv</code>。</p><p>与方法调用相同，使用值调用以指针作为接收者的非接口方法会自动对值取址：<code>pt.Mv</code> 等价于 <code>(&amp;pt).Mv</code>。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">f := t.Mv; f(7)   // like t.Mv(7)f := pt.Mp; f(7)  // like pt.Mp(7)f := pt.Mv; f(7)  // like (*pt).Mv(7)f := t.Mp; f(7)   // like (&amp;t).Mp(7)f := makeT().Mp   // invalid: result of makeT() is not addressable<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>尽管上面使用的都是非接口类型的例子，不过对于接口类型同样适用。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">var i interface { M(int) } = myValf := i.M; f(7)  // like i.M(7)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="index表达式"><a href="#index表达式" class="headerlink" title="index表达式"></a>index表达式</h4><p>主要表达式格式：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">a[x]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以表示数组元素、数组的指针、切片、字符串或 map 类型 a 索引 x 对应的值。x 称作索引或者 map 的键。遵循以下规则：</p><p>如果a不是 map 类型：</p><ul><li><p>索引 x 必须是整型或无类型常量。</p></li><li><p>常量索引必须是非负数且可以使用 int 类型表示。</p></li><li><p>无类型的常量索引会作为 int 型的值。</p></li><li><p>索引 x 的范围在 <code>0&lt;=x&lt;len(a)</code> 内，否则就是越界。</p></li></ul><p>对于数组类型 A：</p><ul><li><p>常量索引必须在合法范围内。</p></li><li><p>如果 x 在运行时越界会引起运行时恐慌。</p></li><li><p><code>a[x]</code> 表示数组在索引 x 处的元素。<code>a[x]</code> 的类型就是 A 的元素类型。</p></li></ul><p>对于数组的指针类型：</p><ul><li>可以使用 <code>a[x]</code> 表示 <code>(*a)[x]</code>。</li></ul><p>对于切片类型 S：</p><ul><li>如果 x 在运行时越界会引起运行时恐慌。</li><li><code>a[x]</code> 表示切片在索引 x 处的元素。<code>a[x]</code> 的类型就是 S 的元素类型。</li></ul><p>对于字符串类型：</p><ul><li><p>如果字符串 a 为常量，那么常量索引必须在合法范围内。</p></li><li><p>如果 x 在运行时越界会引起运行时恐慌。</p></li><li><p>a[x] 表示索引 x 处的非常量字节，它是byte类型。</p></li><li><p>不能对 a[x] 分配值。</p></li></ul><p>对于 map 类型 M：</p><ul><li><p>必须保证 x 的类型能够给 M 的键分配值。</p></li><li><p>如果map包含键为 x 的值，a[x] 就是 map 中键 x 对应的值，它的类型就是 M 的元素类型。</p></li><li><p>如果 map 值为 nil 或不包含这个实体，那么 a[x] 为 M 元素类型的零值。</p></li></ul><p>否则 a[x] 就是非法的。</p><p>基于 <code>map[K]V</code> 类型  a 的索引表达式可以使用特殊格式的赋值和初始化语法。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">v, ok = a[x]v, ok := a[x]var v, ok = a[x]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>它会额外生成一个无类型的布尔值。如果 ok 是 true，那么代表在map中有该键，如果没有 ok 为 false。</p><p>给一个值为 nil 的 map 类型变量赋值会导致运行时恐慌。</p><h4 id="切片表达式"><a href="#切片表达式" class="headerlink" title="切片表达式"></a>切片表达式</h4><p>切片表达式可以基于字符串、数组、数组指针、切片创建字符串子串或切片。它有两种变体，一种是简单的格式是指定开始和结束位置，完全格式的语法还可以指定容量。</p><p>####### 简单切片表达式</p><p>对于数组、字符串、指针数组、切片 a，主要表达式：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">a[low:high]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以构造字符串子串或切片。索引 <code>low</code> 和 <code>high</code> 决定结果切片中的元素。结果切片的索引从 0 开始，长度为 <code>high - low</code>。从数组切分出的切片 s 拥有类型 <code>[]int</code>，长度为 3 ，容积为 4。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">a := [5]int{1, 2, 3, 4, 5}s := a[1:4]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">s[0] == 2s[1] == 3s[2] == 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>为了方便起见，索引值都可以缺省。当 low 缺省时默认从 0 开始。当缺 high 缺省时默认的取切片的长度。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">a[2:]  // same as a[2 : len(a)]a[:3]  // same as a[0 : 3]a[:]   // same as a[0 : len(a)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果 a 是一个数组指针，那么 <code>a[low:high]</code> 可以表示 <code>(*a)[low : high]</code>。</p><p>对于数组或者字符串，索引的范围是<code>0&lt;=low&lt;=high&lt;=len(a)</code>。对于切片，最大的索引值可以为切片的容量，而不是切片的长度。常量索引必须为非负数，且能够转换成 int 类型。对于数组或者常量字符串。常量索引值必须在合法范围内。如果2个索引都是常量。low 必须小于 high。如果索引在运行时访问了非法内存，程序会发生运行时恐慌。</p><p>除了无类型字符串，对于切片和字符串的操作结果是非常量类型的值，它的类型与运算元相同。如果运算元为无类型字符串，那么结果类型会为 string。如果把数组作为运算元，它必须是可寻址的，并且获得的切片和原数组具有同一元素类型。</p><p>如果切片运算元为 nil，那么结果也是 nil。否则结果切片会和运算元共享相同的底层无类型数组。</p><h6 id="完全切片表达式"><a href="#完全切片表达式" class="headerlink" title="完全切片表达式"></a>完全切片表达式</h6><p>对于数组，数组指针或非字符串切片，主要表达式为：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">a[low : high : max]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>它会构造一个同类型切片，并具有与简单切片表达式的 <code>a[low:high]</code> 相同的长度和元素。另外，它还可以把切片的容量设置为 <code>max - low</code>。这时只有第一个索引可以为缺省值，默认为零。从数组中获得切片以后：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">a := [5]int{1, 2, 3, 4, 5}t := a[1:3:5]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>切片 t 为 []int 类型，长度为 2，容量为 4，并且元素为：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">t[0] == 2t[1] == 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>和简单切片表达式一样，如果 a 是数组指针 ，那么 <code>a[low:high:max]</code> 可以简写为 <code>(*a)[low:high:max]</code>。如果切分操作元是数组，那么这个数组必须是可以寻址的。</p><p>如果索引必须在 <code>0 &lt;= low &lt;= high &lt;= max &lt;= cap(a)</code> 范围内。常量索引不能是负数并且能够使用 <code>int</code> 类型表示；对于数组，索引必须在合法范围内。如果有多个索引都是常量的，那么所有索引都需要在合法范围内。如果索引是非法的，会引起运行时恐慌。</p><h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><p>对于接口类型 x 和类型 T，主要表达式：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">x.(T)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以断言 x 不是 nil  且 x 的值是 T 类型。标记 x.(T) 叫做类型断言。</p><p>更确切的说，如果 T 不是接口类型，那么 x.(T) 将会断言动态类型 x 的类型是不是 T。</p><p>这时，T 必须实现了 x 的（接口）类型。否则断言会是非法的因为 x 不能保存 T 类型的值。如果 T 是接口类型，那么可以断言动态类型 x 是否实现了 T 接口。</p><p>如果类型断言成功，表达式的值为 x 的值，但它的类型是T。如果断言失败，将会导致运行时恐慌。换句话说，即使 x 是运行时确定的，x.(T) 也必须是编程时就确认存在的。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">var x interface{} = 7          // x 拥有动态类型 int 值为 7i := x.(int)                   // i 为 int 类型值为 7type I interface { m() }func f(y I) {   s := y.(string)        // 非法: 字符串没有实现接口 I （缺少 m 方法）   r := y.(io.Reader)     // r 拥有接口 io.Reader 所以 y 的动态类型必须同时实现 I 和 io.Reader   …}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类型断言可以使用特定格式的赋值和初始化语句。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">v, ok = x.(T)v, ok := x.(T)var v, ok = x.(T)var v, ok T1 = x.(T)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这时将会额外生成一个无类型的布尔值。如果断言成功，ok返回 <code>true</code>，否则是 <code>false</code>。并且 v 会是 T 类型的零值。这时不会有恐慌发生。</p><h4 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h4><p>给定函数类型为 F 的表达式 f：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">f(a1, a2, … an)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以使用 a1,a2…an 来调用函数 f。除一种特殊情况之外，函数参数必须是对应 F 函数参数类型的单值表达式，且在函数调用前就已经完成求值。表达式的结果类型是 f 的结果类型。函数调用和方法调用相似，只是方法额外需要一个接收者类型。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">math.Atan2(x, y)  // function callvar pt *Pointpt.Scale(3.5)     // method call with receiver pt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在函数调用中，函数的值和参数是按照顺序求值的。在计算之后作为参数会传进函数，函数开始执行。当函数执行完成后返回的参数将会返回给函数的调用者。</p><p>调用值为 nil 的函数会导致运行时恐慌。</p><p>作为特例，如果函数或者方法的返回值等于参数列表的个数，那么会嵌套调用。这将把返回值直接赋值给下一次调用函数的参数。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func Split(s string, pos int) (string, string) {return s[0:pos], s[pos:]}func Join(s, t string) string {return s + t}if Join(Split(value, len(value)/2)) != value {log.Panic("test fails")}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果 x 的方法集中包含 m 那么 <code>x.m()</code> 是合法的。并且参数列表和 m 的参数列表相同。如果x是可寻址的，那么那么x指针的方法集<code>(&amp;x).m()</code>可以简写成<code>x.m()</code>。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">var p Pointp.Scale(3.5)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>没有方法类型，也没有方法字面值。</p><h4 id="通过-来传递参数"><a href="#通过-来传递参数" class="headerlink" title="通过 ... 来传递参数"></a>通过 <code>...</code> 来传递参数</h4><p>如果 f 的最后一个参数 p 的类型是 <code>...T</code>。那么在函数内部 p 参数的类型就是 <code>[]T</code>。如果 f 调用时没有传入 p 对应的参数，那么p为 nil。否则这些参数会以切片方式传入，在新的底层切片中。切片中的类型都是能赋值给类型 T 的值。这个切片的长度和容量在不同的调用中有所不同。</p><p>给定函数调用：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func Greeting(prefix string, who ...string)Greeting("nobody")Greeting("hello:", "Joe", "Anna", "Eileen")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在 <code>Greeting</code> 中，第一次调用时，<code>who</code>是 nil 类型。而在第二次调用时是<code>[]string{"Joe", "Anna", "Eileen"}</code>。</p><p>如果在调用的时候的最后一个参数是[]T，那么我们可以使用<code>...</code>来将切片中的值依次赋值给参数列表。</p><p>给定切片s并且调用:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">s := []string{"James", "Jasmine"}Greeting("goodbye:", s...)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>z 在 <code>Greeting</code>。中 <code>who</code> 会和切片 s 共享相同的底层数组。</p><h4 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h4><p>操作符用来连接运算元。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">Expression = UnaryExpr | Expression binary_op Expression .UnaryExpr  = PrimaryExpr | unary_op UnaryExpr .binary_op  = "||" | "&amp;&amp;" | rel_op | add_op | mul_op .rel_op     = "==" | "!=" | "&lt;" | "&lt;=" | "&gt;" | "&gt;=" .add_op     = "+" | "-" | "|" | "^" .mul_op     = "*" | "/" | "%" | "&lt;&lt;" | "&gt;&gt;" | "&amp;" | "&amp;^" .unary_op   = "+" | "-" | "!" | "^" | "*" | "&amp;" | "&lt;-" .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>比较运算符在此处讨论。对于其他二元操作符，两个操作元的类型必须是相同的，除了位移和无类型常量。针对常量的操作，请看常量表达式章节。</p><p>除了位移操作，如果其中一个操作符是无类型常量，而另个不是，那么无类型的常量会转换成另一个运算元的类型。</p><p>在右移表达式中的运算元必须是无符号的整数或者可以转换成 uint 的无类型的常量。如果左移一个无类型常量那么结果依然是无类型的。他首先会转换成指定类型。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">var s uint = 33var i = 1&lt;&lt;s           // 1 has type intvar j int32 = 1&lt;&lt;s     // 1 has type int32; j == 0var k = uint64(1&lt;&lt;s)   // 1 has type uint64; k == 1&lt;&lt;33var m int = 1.0&lt;&lt;s     // 1.0 has type int; m == 0 if ints are 32bits in sizevar n = 1.0&lt;&lt;s == j    // 1.0 has type int32; n == truevar o = 1&lt;&lt;s == 2&lt;&lt;s   // 1 and 2 have type int; o == true if ints are 32bits in sizevar p = 1&lt;&lt;s == 1&lt;&lt;33  // illegal if ints are 32bits in size: 1 has type int, but 1&lt;&lt;33 overflows intvar u = 1.0&lt;&lt;s         // illegal: 1.0 has type float64, cannot shiftvar u1 = 1.0&lt;&lt;s != 0   // illegal: 1.0 has type float64, cannot shiftvar u2 = 1&lt;&lt;s != 1.0   // illegal: 1 has type float64, cannot shiftvar v float32 = 1&lt;&lt;s   // illegal: 1 has type float32, cannot shiftvar w int64 = 1.0&lt;&lt;33  // 1.0&lt;&lt;33 is a constant shift expression<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h6><p>一元运算符拥有最高优先级。++ 和 – 是语句而不是表达式，他们在运算符的优先级之外。所以 (*p)++ 和 *p++ 是一样的。</p><p>二元运算符有 5 个优先级。乘法运算符在最高级，紧接着是加法运算符。比较运算符，&amp;&amp; 运算符，最后是 ||。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">Precedence    Operator    5             *  /  %  &lt;&lt;  &gt;&gt;  &amp;  &amp;^    4             +  -  |  ^    3             ==  !=  &lt;  &lt;=  &gt;  &gt;=    2             &amp;&amp;    1             ||<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>相同优先级的二元运算符的执行顺序是由左到右。例如 <code>x/y*z</code>和<code>(x/y)*z</code> 是一样的。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">+x23 + 3*x[i]x &lt;= f()^a &gt;&gt; bf() || g()x == y+1 &amp;&amp; &lt;-chanPtr &gt; 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h4><p>算数运算符应用在 2 个数字值之间，别切生成一个相同类型的值作为第一个运算元。四种算数运算符(+,-,*,/)应用在数字，浮点，复合类型之中。+ 也可以用于字符串。位运算和位移运算只适用于整数。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">+    sum                    integers, floats, complex values, strings-    difference             integers, floats, complex values*    product                integers, floats, complex values/    quotient               integers, floats, complex values%    remainder              integers&amp;    bitwise AND            integers|    bitwise OR             integers^    bitwise XOR            integers&amp;^   bit clear (AND NOT)    integers&lt;&lt;   left shift             integer &lt;&lt; unsigned integer&gt;&gt;   right shift            integer &gt;&gt; unsigned integer<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="数字运算符"><a href="#数字运算符" class="headerlink" title="数字运算符"></a>数字运算符</h6><p>对于两个整数 x 和 y。整数商 <code>q=x/y</code> 和余数 <code>r=x%y</code> 遵循以下规律。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">x = q*y + r  and  |r| &lt; |y|<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>x/y</code> 截断为 0。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">x     y     x / y     x % y 5     3       1         2-5     3      -1        -2 5    -3      -1         2-5    -3       1        -2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>作为这个规则的例外情况，如果 x 非常大，那么 <code>q=x/-1</code> 等于 x。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">x, qint8                     -128int16                  -32768int32             -2147483648int64    -9223372036854775808<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果除数是一个常量。那么它不能是 0，如果除数在运行时为 0，会导致运行时恐慌。如果除数是负数并且除数是：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">x     x / 4     x % 4     x &gt;&gt; 2     x &amp; 3 11      2         3         2          3-11     -2        -3        -3          1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>位移运算符移动左侧运算元右侧元算元指定的位数。如果左侧是有符号整型，那它就实现了位移运算，如果是无符号整数使用逻辑位移。位移运算没有上限，位移操作让左边运算元位移 n 个 1。<code>x&lt;&lt;1</code> 和 <code>x*2</code> 是相等的。并且 <code>x&gt;&gt;1</code> 和 <code>x/2</code> 是相同的。</p><p>对于整数运算元，一元运算符+-^定义如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">+x                          is 0 + x-x    negation              is 0 - x^x    bitwise complement    is m ^ x  with m = "all bits set to 1" for unsigned x                                      and  m = -1 for signed x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h6 id="整型溢出"><a href="#整型溢出" class="headerlink" title="整型溢出"></a>整型溢出</h6><p>对于无符号的值，运算符+-*和&lt;&lt;都是2禁止运算。这里的n是无符号类型的宽度，无符号整型将会丢弃溢出的位，并且程序将会返回<code>wrap around</code>。</p><p>对于有符号的整数，操作符+=*&lt;&lt;都会溢出并且值存在，并且代表相应的有符号的值。在运算时不会抛出异常。标一起不会报错。所以不是所有情况下x&lt;x+1都成立。</p><h6 id="浮点数运算符"><a href="#浮点数运算符" class="headerlink" title="浮点数运算符"></a>浮点数运算符</h6><p>对于浮点数和其他复杂数字，+x和x是一样的，-x是x的对立面。除了IEEE-754还没有指定浮点数除0或者复数的结果。是否抛出异常将会依赖其具体实现。</p><p>一种实现可以合并多个浮点操作进一个操作，有可能是夸语句的，并且他的结果可能和依次单独执行的结果不一样。1个浮点数类型将会转变成目标的精度，防止四舍五入的融合。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">// FMA allowed for computing r, because x*y is not explicitly rounded:r  = x*y + zr  = z;   r += x*yt  = x*y; r = t + z*p = x*y; r = *p + zr  = x*y + float64(z)// FMA disallowed for computing r, because it would omit rounding of x*y:r  = float64(x*y) + zr  = z; r += float64(x*y)t  = float64(x*y); r = t + z<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h6><p>字符串可以使用+和+=操作符。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">s := "hi" + string(c)s += " and good bye"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>字符串想家将会创建一个新的字符串。</p><h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><p>比较运算符比较连个运算元，并且生成一个无类型的布尔值。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">==    equal!=    not equal&lt;     less&lt;=    less or equal&gt;     greater&gt;=    greater or equal<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在任何比较运算元中2种类型必须是可以分配的。</p><p>使用等于运算符<code>==</code>和<code>!=</code>的运算元必须是可比较的。使用顺序运算符<code>&lt;</code>,<code>&lt;=</code>,<code>&gt;</code>和<code>&gt;=</code>必须是可比较的。这些限制导致比较运算符被定义成以下的方式。</p><ul><li><p>布尔值是可比较的，两个布尔值当他们同为<code>true</code>或者false的使用是相等的</p></li><li><p>整数值是可比较和排序的</p></li><li><p>浮点数是可比较和排序的，具体定义在IEEE-754标准中。</p></li><li><p>复数是可比较的，2个复数当实部和虚部都相等时就是相等的。</p></li><li><p>字符串是可以比较和排序的。是按照字节顺序排序。</p></li><li><p>指针式可以排序的，连个指针当指向相同变量时是相同的，或者他们2个都是nil。指向一个为非配的变量的结果是未定义的。</p></li><li><p>channel是可比较的。当两个管道是用同一个make出来的，或者都是nil时时相等的。</p></li><li><p>接口值时可以比较的，2个接口值时相等的如果2个标识符的动态类型是一样的或者他们都是nil。</p></li><li><p>一个非接口类型的值x和一个接口类型的值T在非接口类型是可以比较的并且非接口类型实现了接口是是可以比较的。当他们的动态类型类型相同时时相等的。</p></li><li><p>当结构体内的所有字段都是可以比较的时候，他是可以比较的。连个结构体的值当非空字段都相等时他们是相等的。</p></li><li><p>数组类型的值时可比较的，如果数组的原属时可以比较的，那么当数组的所有值是相等的时候他们就是相等的。</p></li></ul><p>使用两个动态类型的标识符来比较接口的值。如果这个类型的值时不可比较的，那么将会引起一个panic。这个行为不仅仅时接口，数组结构体接口字段都有这个问题。</p><p>切片，map，和函数值都是不可比较的，然而，作为一个特殊的例子，切片，map和函数的值的nil时可以比较的，指针，channel和接口的值nil也是可以比较的。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">const c = 3 &lt; 4            // c is the untyped boolean constant truetype MyBool boolvar x, y intvar (// The result of a comparison is an untyped boolean.// The usual assignment rules apply.b3        = x == y // b3 has type boolb4 bool   = x == y // b4 has type boolb5 MyBool = x == y // b5 has type MyBool)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h4><p>逻辑运算符使用布尔值值，并且生成一个相同类型的结果值作为操作元。右面的操作元计算是有条件的。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">&amp;&amp;    conditional AND    p &amp;&amp; q  is  "if p then q else false"||    conditional OR     p || q  is  "if p then true else q"!     NOT                !p      is  "not p"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="地址操作符"><a href="#地址操作符" class="headerlink" title="地址操作符"></a>地址操作符</h4><p>以类型 T 的 x 作为运算元，取址操作 <code>&amp;x</code> 会生成一个类型为 <code>*T</code> 并指向 x 的指针。运算元必须是能够取址的，它可以是一个变量，指针，切片的取值操作；或是一个可取址结构体的字段选择器；或是对于可取址数组的索引取值操作。作为寻址能力的例外，x 可能是一个复合字面值。如果对 x 进行取址操作将会 panic，<code>&amp;x</code> 也会 panic。</p><p>对于一个 <code>*T</code> 类型的运算元 x，指针解引用 <code>*x</code> 表示 x 指向的 T 类型。如果 x 为 nil，那么解引用 <code>*x</code> 会 panic。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">&amp;x&amp;a[f(2)]&amp;Point{2, 3}*p*pf(x)var x *int = nil*x   // causes a run-time panic&amp;*x  // causes a run-time panic<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="接收操作符"><a href="#接收操作符" class="headerlink" title="接收操作符"></a>接收操作符</h4><p>对于管道类型的运算元 <code>ch</code>，接收操作 <code>&lt;-ch</code> 返回值是管道 <code>ch</code> 接收到的值。带方向的管道需要有接受权限，接收操作的类型也是通道的元素类型。表达式会一直阻塞直到接收到返回值。从 nil 通道接收值会一直阻塞。从一个已经关闭的通道接收数据会在其他数据都被接收以后生成该通道元素类型的零值。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">v1 := &lt;-chv2 = &lt;-chf(&lt;-ch)&lt;-strobe  // wait until clock pulse and discard received value<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>接收数据的表达式可以使用赋值表达式。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">x, ok = &lt;-chx, ok := &lt;-chvar x, ok = &lt;-chvar x, ok T = &lt;-ch<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>它还可以生成一个额外的无类型布尔值来表示通道是否关闭。如果 ok 为 <code>true</code> 说明获取到的是发送到通道内的数据，而 <code>false</code> 它就返回一个零值因为通道内没有元素且已经关闭。</p><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>类型转换表达式 <code>T(x)</code> 其中 T 代表类型，x 代表可以转换成 T 类型的表达式。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">Conversion = Type "(" Expression [ "," ] ")" .<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果类型是以 <code>*</code> 或 <code>&lt;-</code> 开头，或以关键字 <code>func</code> 开头并且没有返回值列表，那么它必须用括号括起来避免歧义：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">*Point(p)        // same as *(Point(p))(*Point)(p)      // p is converted to *Point&lt;-chan int(c)    // same as &lt;-(chan int(c))(&lt;-chan int)(c)  // c is converted to &lt;-chan intfunc()(x)        // function signature func() x(func())(x)      // x is converted to func()(func() int)(x)  // x is converted to func() intfunc() int(x)    // x is converted to func() int (unambiguous)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>常量 x 可以在可以用类型 T 表示时自动转换。作为一个特例，整数常量 x 可以转换成字符串类型就和非常量 x 一样。</p><p>对常量的转换会生成一个指定类型的常量。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">uint(iota)               // iota value of type uintfloat32(2.718281828)     // 2.718281828 of type float32complex128(1)            // 1.0 + 0.0i of type complex128float32(0.49999999)      // 0.5 of type float32float64(-1e-1000)        // 0.0 of type float64string('x')              // "x" of type stringstring(0x266c)           // "♬" of type stringMyString("foo" + "bar")  // "foobar" of type MyStringstring([]byte{'a'})      // not a constant: []byte{'a'} is not a constant(*int)(nil)              // not a constant: nil is not a constant, *int is not a boolean, numeric, or string typeint(1.2)                 // illegal: 1.2 cannot be represented as an intstring(65.0)             // illegal: 65.0 is not an integer constant<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>非常量 x 可以在以下情况下转换成类型 T：</p><ul><li><p>x 可以给类型 T 赋值</p></li><li><p>忽略的结构体标签，x 的类型和 T 具有相同的底层类型</p></li><li><p>忽略的结构体标签，x 的类型和 T 都是指针类型，并且指针所指的类型具有相同的底层类型</p></li><li><p>x 的类型和 T 都是整数或者浮点数类型</p></li><li><p>x 的类型和 T 都是复数类型</p></li><li><p>x 是一个字符串而 T 时字节切片或者 rune 切片</p></li></ul><p>在比较两个结构体类型的时候会忽略结构体标签：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">type Person struct {Name    stringAddress *struct {Street stringCity   string}}var data *struct {Name    string `json:"name"`Address *struct {Street string `json:"street"`City   string `json:"city"`} `json:"address"`}var person = (*Person)(data)  // ignoring tags, the underlying types are identical<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个规则也适用于数字类型与字符串类型间的相互转换。这个转换可能会改变 x 的值并且会增加运行时消耗。包 unsafe 实现了这个功能底层的限制。</p><h6 id="数字之间的转换"><a href="#数字之间的转换" class="headerlink" title="数字之间的转换"></a>数字之间的转换</h6><p>对于非常量的数字转换，需要遵守以下规则：</p><ul><li><p>在转换整型数字时，如果是一个有符号整型，它是继承有符号的无限精度；否则就不用继承符号。转换时会截断数字以适应类型的大小。例如：如果 <code>v:=uint16(0x10F0)</code>，然后 ``uint32(int8(v)) == 0xFFFFFFF0 。类型转换总是生成有效值，并且永远不会溢出。</p></li><li><p>如果要将浮点数转换成整型，会丢弃小数部分（截断为零）。</p></li><li><p>如果要将整型或浮点型转换成浮点数类型，或或者一个复数转换成其他复数类型，结果会四舍五入成指定精度。例如： 可以使用超出IEEE-754 32位数的附加精度来存储float32类型的变量x的值，但float32（x）表示将x的值舍入为32位精度的结果。x + 0.1 会使用超过 32 位的精度，而 <code>float32(x+0.1)</code> 不会。</p></li></ul><p>在所有浮点数和复数的非常量转换中，如果结构类型不能成功表示数据，那么结果将会依赖于具体平台实现。</p><h6 id="字符串的类型转换"><a href="#字符串的类型转换" class="headerlink" title="字符串的类型转换"></a>字符串的类型转换</h6><ol><li>转换一个有符号或者无符号的整型值会转换成对应的 UTF-8 表示整型值。不在范围内的 Unicode 代码点会转换成 “\uFFFD”。</li></ol><pre class="line-numbers language-go" data-language="go"><code class="language-go">string('a')       // "a"string(-1)        // "\ufffd" == "\xef\xbf\xbd"string(0xf8)      // "\u00f8" == "ø" == "\xc3\xb8"type MyString stringMyString(0x65e5)  // "\u65e5" == "日" == "\xe6\x97\xa5"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>将字节切片转换成字符串类型会生成一个由切片元素组成的字符串</li></ol><pre class="line-numbers language-go" data-language="go"><code class="language-go">string([]byte{'h', 'e', 'l', 'l', '\xc3', '\xb8'})   // "hellø"string([]byte{})                                     // ""string([]byte(nil))                                  // ""type MyBytes []bytestring(MyBytes{'h', 'e', 'l', 'l', '\xc3', '\xb8'})  // "hellø"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>将 rune 切片转换成字符串类型会生成一个由切片元素组成的字符串</li></ol><pre class="line-numbers language-go" data-language="go"><code class="language-go">string([]rune{0x767d, 0x9d6c, 0x7fd4})   // "\u767d\u9d6c\u7fd4" == "白鵬翔"string([]rune{})                         // ""string([]rune(nil))                      // ""type MyRunes []runestring(MyRunes{0x767d, 0x9d6c, 0x7fd4})  // "\u767d\u9d6c\u7fd4" == "白鵬翔"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>将字符串转换成字节切片会生成由字符串中每个字节组成的切片</li></ol><pre class="line-numbers language-go" data-language="go"><code class="language-go">[]byte("hellø")   // []byte{'h', 'e', 'l', 'l', '\xc3', '\xb8'}[]byte("")        // []byte{}MyBytes("hellø")  // []byte{'h', 'e', 'l', 'l', '\xc3', '\xb8'}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol><li>将字符串转换成 rune 切片会生成由字符串中每个 Unicode 代码点组成的切片</li></ol><pre class="line-numbers language-go" data-language="go"><code class="language-go">[]rune(MyString("白鵬翔"))  // []rune{0x767d, 0x9d6c, 0x7fd4}[]rune("")                 // []rune{}MyRunes("白鵬翔")           // []rune{0x767d, 0x9d6c, 0x7fd4}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h6 id="常量表达式"><a href="#常量表达式" class="headerlink" title="常量表达式"></a>常量表达式</h6><p>常量表达式只包含常量运算元并且在编译程序时就已经计算完成。</p><p>无类型布尔值，数值和字符串常量都可以当作运算元。除了位置操作符，如果二元运算符石不同类型的常量，操作元，和非布尔值，和即将在接下来出现的：整型，rune，浮点数和复数类型。例如：一个无类型整型常量减去无类型复数常量，结果为复数常量。</p><p>一个常量的比较运算会生成无类型的布尔常量。如果左移运算是一个无类型常量，结果会是一个整型常量。它会和原来常量为相同类型。其他与无类型常量的运算都会生成相同类型的结果（布尔值，整型，浮点数，复数，字符串常量）。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">const a = 2 + 3.0          // a == 5.0   (untyped floating-point constant)const b = 15 / 4           // b == 3     (untyped integer constant)const c = 15 / 4.0         // c == 3.75  (untyped floating-point constant)const Θ float64 = 3/2      // Θ == 1.0   (type float64, 3/2 is integer division)const Π float64 = 3/2.     // Π == 1.5   (type float64, 3/2. is float division)const d = 1 &lt;&lt; 3.0         // d == 8     (untyped integer constant)const e = 1.0 &lt;&lt; 3         // e == 8     (untyped integer constant)const f = int32(1) &lt;&lt; 33   // illegal    (constant 8589934592 overflows int32)const g = float64(2) &gt;&gt; 1  // illegal    (float64(2) is a typed floating-point constant)const h = "foo" &gt; "bar"    // h == true  (untyped boolean constant)const j = true             // j == true  (untyped boolean constant)const k = 'w' + 1          // k == 'x'   (untyped rune constant)const l = "hi"             // l == "hi"  (untyped string constant)const m = string(k)        // m == "x"   (type string)const Σ = 1 - 0.707i       //            (untyped complex constant)const Δ = Σ + 2.0e-4       //            (untyped complex constant)const Φ = iota*1i - 1/1i   //            (untyped complex constant)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对一个无类型整数，rune，或浮点数应用内置的 <code>complex</code> 函数会生成无类型的复数常量。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">const ic = complex(0, c)   // ic == 3.75i  (untyped complex constant)const iΘ = complex(0, Θ)   // iΘ == 1i     (type complex128)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>常量表达式总是一个明确的值；中间值和常量自己可以比语言所支持的精度更高，下面的声明是合法的：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">const Huge = 1 &lt;&lt; 100         // Huge == 1267650600228229401496703205376  (untyped integer constant)const Four int8 = Huge &gt;&gt; 98  // Four == 4                                (type int8)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>常量的除法的除数不能为 0:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">3.14 / 0.0   // illegal: division by zero<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>定义了类型的常量的精度必须根据常量类型定义。所以下面的常量表达式是非法的：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">uint(-1)     // -1 cannot be represented as a uintint(3.14)    // 3.14 cannot be represented as an intint64(Huge)  // 1267650600228229401496703205376 cannot be represented as an int64Four * 300   // operand 300 cannot be represented as an int8 (type of Four)Four * 100   // product 400 cannot be represented as an int8 (type of Four)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>补码使用的一元操作符 ^ 对于非常量的匹配模式：补码对于无符号常量为 1，对于有符号和无类型常量为 -1。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">^1         // untyped integer constant, equal to -2uint8(^1)  // illegal: same as uint8(-2), -2 cannot be represented as a uint8^uint8(1)  // typed uint8 constant, same as 0xFF ^ uint8(1) = uint8(0xFE)int8(^1)   // same as int8(-2)^int8(1)   // same as -1 ^ int8(1) = -2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实现限制：编译器在处理无类型浮点数和复数时会取近似值；具体请看常量章节。这个取近似值的操作在浮点数在整数上下文时会产生无效值，即使在计算过后是一个整型。</p><h4 id="运算优先级"><a href="#运算优先级" class="headerlink" title="运算优先级"></a>运算优先级</h4><p>在包级别，初始化的依赖性由变量声明的初始化表达式顺序决定。否则，当计算表达式内的操作数时，赋值，返回语句，所有函数调用，方法调用，和通信操作都会由左向右计算。</p><p>例如，在函数作用域中的赋值：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">y[f()], ok = g(h(), i()+x[j()], &lt;-c), k()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>函数调用和通信的发生顺序为：<code>f()</code>，<code>h()</code>，<code>i()</code>，<code>j()</code>，<code>&lt;-c</code>，<code>g()</code> 和 <code>k()</code>。但是对 y 和 x 的取值操作没有指定。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">a := 1f := func() int { a++; return a }x := []int{a, f()}            // x may be [1, 2] or [2, 2]: evaluation order between a and f() is not specifiedm := map[int]int{a: 1, a: 2}  // m may be {2: 1} or {2: 2}: evaluation order between the two map assignments is not specifiedn := map[int]int{a: f()}      // n may be {2: 3} or {3: 3}: evaluation order between the key and the value is not specified<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在包级别，依赖的初始化顺序会覆盖这个从左向右的规则：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">var a, b, c = f() + v(), g(), sqr(u()) + v()func f() int        { return c }func g() int        { return a }func sqr(x int) int { return x*x }// functions u and v are independent of all other variables and functions<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p>语句控制程序的执行。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">Statement =Declaration | LabeledStmt | SimpleStmt |GoStmt | ReturnStmt | BreakStmt | ContinueStmt | GotoStmt |FallthroughStmt | Block | IfStmt | SwitchStmt | SelectStmt | ForStmt |DeferStmt .SimpleStmt = EmptyStmt | ExpressionStmt | SendStmt | IncDecStmt | Assignment | ShortVarDecl .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="终止语句"><a href="#终止语句" class="headerlink" title="终止语句"></a>终止语句</h4><p>终止语句会阻止相同代码块中下面所有语句的执行。以下语句属于终止语句：</p><ol><li><p><code>return</code> 和 <code>goto</code> 语句</p></li><li><p>对内置 <code>panic</code> 函数的调用</p></li><li><p>代码块结束</p></li><li><p><code>if</code> 语句中：</p></li><li><p>else 分支</p></li><li><p>所有分支末尾</p></li><li><p><code>for</code>语句中：</p></li><li><p><code>break</code> 语句和循环结束</p></li><li><p><code>switch</code> 语句：</p></li><li><p>在 <code>switch</code> 语句中没有 <code>break</code> 语句，</p></li><li><p>有一个默认的 case</p></li><li><p>语句列表中的每个 case 语句和有可能存在的 <code>fallthrough</code> 语句</p></li><li><p><code>select</code> 语句中：</p></li><li><p>没有 break 语句</p></li><li><p>每个 case 中的语句列表，如果包含默认 case</p></li></ol><p>所有其他语句都不是中断语句。</p><p>如果语句序列不为空并且最后一个非空语句是终止语句，那么语句序列就以终结语句结尾。</p><h4 id="空语句"><a href="#空语句" class="headerlink" title="空语句"></a>空语句</h4><p>空语句不做任何事情。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">EmptyStmt = .<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="标签语句"><a href="#标签语句" class="headerlink" title="标签语句"></a>标签语句</h4><p>标签语句可以作为 <code>goto</code>，<code>break</code> 和 <code>continue</code> 语句的目标。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">LabeledStmt = Label ":" Statement .Label       = identifier .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">Error: log.Panic("error encountered")<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="表达式语句"><a href="#表达式语句" class="headerlink" title="表达式语句"></a>表达式语句</h4><p>除了特定的内置函数，一般的函数、方法和接收操作都可以出现在表达式语句的上下文中。这些语句可以使用括号括起来。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">ExpressionStmt = Expression .<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下面的内置函数不允许出现在语句的上下文中：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">append cap complex imag len make new realunsafe.Alignof unsafe.Offsetof unsafe.Sizeof<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">h(x+y)f.Close()&lt;-ch(&lt;-ch)len("foo")  // illegal if len is the built-in function<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="发送语句"><a href="#发送语句" class="headerlink" title="发送语句"></a>发送语句</h4><p>发送语句可以向通道发送一个值。通道表达式必须是通道类型，通道方向必须允许发送操作，并且值类型是可以分配给通道元素通道类型。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">SendStmt = Channel "&lt;-" Expression .Channel  = Expression .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>通道类型和值表达式会在发送之前求值。发送操作会一致阻塞，直到可以进行发送操作。如果接收者已经准备好向没有缓存的通道发送值可以立即执行。如果通道内还有缓存空间，向通道内发送值也会立即执行。向关闭的通道发送数据会导致运行时恐慌。像值为 nil 的通道发送数据会一直阻塞。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">ch &lt;- 3  // send value 3 to channel ch<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="递增-递减语句"><a href="#递增-递减语句" class="headerlink" title="递增/递减语句"></a>递增/递减语句</h4><p>“++” 和 “–” 语句可以递增或者递减运算元一个无类型常量 1。作为一个赋值语句，运算元必须是可寻址的或者 map 的索引表达式。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">IncDecStmt = Expression ( "++" | "--" ) .<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下面的赋值语句在语义上是等价的：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">IncDec statement    Assignmentx++                 x += 1x--                 x -= 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go">Assignment = ExpressionList assign_op ExpressionList .assign_op = [ add_op | mul_op ] "=" .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>所有左侧运算元都必须是可寻址的、map 索引表达式或空标识符其中之一。运算元可以用括号括起来。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">x = 1*p = f()a[i] = 23(k) = &lt;-ch  // same as: k = &lt;-ch<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>对于赋值操作 <code>x op= y</code> 其中 <code>op</code> 为二元运算符，它和 <code>x=x op (y)</code> 是等价的，不过它只计算一次 x。<code>op=</code> 是单独的一个词汇单元，在赋值操作中左侧表达式和右侧表达式必须都是单值表达式，并且左侧表达式不能是空白标识符。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">a[i] &lt;&lt;= 2i &amp;^= 1&lt;&lt;n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>元祖赋值语句会把运算返回的多个值分别分配给变量列表。它有两种格式，第一种：它是返回多值的表达式，例如函数调用、通道和 map 运算、类型断言。左侧运算元的数量必须等于返回值的数量。如果函数返回两个值：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">x, y = f()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>它会将第一个返回值分配给 x ，把第二个返回值分配给 y。第二种格式中，左侧运算元的数量必须等于右侧运算元的数量。每个表达式都只能返回单一值，右侧第 n 个值会赋值给左侧第 n 个变量。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">one, two, three = '一', '二', '三'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>空标识符可以在分配时忽略一个右面位置的表达式：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">_ = x       // evaluate x but ignore itx, _ = f()  // evaluate f() but ignore second result value<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>赋值分为两个阶段。首先会计算左侧运算元的索引表达式和指针的解引用工作并以一定顺序计算右侧表达式的值。</p><p>然后依次对左侧运算元赋值。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">a, b = b, a  // exchange a and bx := []int{1, 2, 3}i := 0i, x[i] = 1, 2  // set i = 1, x[0] = 2i = 0x[i], i = 2, 1  // set x[0] = 2, i = 1x[0], x[0] = 1, 2  // set x[0] = 1, then x[0] = 2 (so x[0] == 2 at end)x[1], x[3] = 4, 5  // set x[1] = 4, then panic setting x[3] = 5.type Point struct { x, y int }var p *Pointx[2], p.x = 6, 7  // set x[2] = 6, then panic setting p.x = 7i = 2x = []int{3, 5, 7}for i, x[i] = range x {  // set i, x[2] = 0, x[0]break}// after this loop, i == 0 and x == []int{3, 5, 3}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在赋值语句中每个值都必须能分配给左侧指定类型的值。除了以下特例：</p><ol><li><p>任何类型都能分配给空标识符。</p></li><li><p>如果把无类型常量分配给接口类型或者空标识符，它会转换成默认类型。</p></li><li><p>如果无类型的布尔值分配给了接口类型或者空标识符，它会先转换成 <code>bool</code> 类型。</p></li></ol><h4 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h4><p><code>if</code> 语句根据布尔值表达式的值来决定执行条件分支的代码。如果表达式为真，就执行 <code>if</code> 分支内的代码，否则执行 <code>else</code> 分支的代码。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">IfStmt = "if" [ SimpleStmt ";" ] Expression Block [ "else" ( IfStmt | Block ) ] .<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">if x &gt; max {x = max}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>表达式可能先于普通语句，它会在表达式求值之前发生。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">if x := f(); x &lt; y {return x} else if x &gt; z {return z} else {return y}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h4><h4 id="for-语句"><a href="#for-语句" class="headerlink" title="for 语句"></a>for 语句</h4><p>for 语句可以用来重复执行一段代码。它有三种格式：迭代器可以是单一条件、for 分句或者 range 语句。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">ForStmt = "for" [ Condition | ForClause | RangeClause ] Block .Condition = Expression .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h6 id="单一条件的-for-语句"><a href="#单一条件的-for-语句" class="headerlink" title="单一条件的 for 语句"></a>单一条件的 for 语句</h6><p>这种情况下 for 会在条件为 true 时一直重复。条件会在每次迭代时都重新计算。如果没有指定条件，默认一直为 true。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">for a &lt; b {a *= 2}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h6 id="带分句的-for-语句"><a href="#带分句的-for-语句" class="headerlink" title="带分句的 for 语句"></a>带分句的 for 语句</h6><p>带分句的 for 语句也是由条件控制，只是它有一个初始化和寄送的过程。例如赋值、递增或者递减语句。初始化语句可以是短变量声明，但是寄送语句不能。在初始化语句中声明的变量可以在迭代过程中使用。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">ForClause = [ InitStmt ] ";" [ Condition ] ";" [ PostStmt ] .InitStmt = SimpleStmt .PostStmt = SimpleStmt .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">for i := 0; i &lt; 10; i++ {f(i)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果初始化语句非空，它会在进入迭代前执行一次；post 语句在每次循环后都会执行一次。在只有条件的情况下可以省略分号。如果缺省条件语句，默认为 true。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">for cond { S() }    is the same as    for ; cond ; { S() }for      { S() }    is the same as    for true     { S() }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h6 id="带-range-分句的-for-语句"><a href="#带-range-分句的-for-语句" class="headerlink" title="带 range 分句的 for 语句"></a>带 range 分句的 for 语句</h6><p>带 range 分句的 for 语句可以访问数组、切片、字符串、map 的所有元素，还可以从通道中接收值。迭代获得元素分配给了相应的迭代变量并执行代码块。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">RangeClause = [ ExpressionList "=" | IdentifierList ":=" ] "range" Expression .<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>右侧的 range 分句表达式叫做 range 表达式，它可能是数组、数组的指针、切片、字符串、map 或通道接收者类型。在分配时，左侧运算元必须是可寻址的或者 map 的索引表达式；它们作为迭代变量。如果 range 表达式是一个通道类型，至少需要有一个变量，它也可以有两个变量。如果迭代变量是空标识符，就代表在分句中不存在该标识符。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">Range expression                          1st value          2nd valuearray or slice  a  [n]E, *[n]E, or []E    index    i  int    a[i]       Estring          s  string type            index    i  int    see below  runemap             m  map[K]V                key      k  K      m[k]       Vchannel         c  chan E, &lt;-chan E       element  e  E<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">var testdata *struct {a *[7]int}for i, _ := range testdata.a {// testdata.a is never evaluated; len(testdata.a) is constant// i ranges from 0 to 6f(i)}var a [10]stringfor i, s := range a {// type of i is int// type of s is string// s == a[i]g(i, s)}var key stringvar val interface {}  // element type of m is assignable to valm := map[string]int{"mon":0, "tue":1, "wed":2, "thu":3, "fri":4, "sat":5, "sun":6}for key, val = range m {h(key, val)}// key == last map key encountered in iteration// val == map[key]var ch chan Work = producer()for w := range ch {doWork(w)}// empty a channelfor range ch {}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Go-语句"><a href="#Go-语句" class="headerlink" title="Go 语句"></a>Go 语句</h4><p><code>go</code> 语句会开始在相同地址空间中的单独 goroutine 中调用函数。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">GoStmt = "go" Expression .<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>表达式必须是函数或者方法调用；它不能使用括号括起来，调用内置函数有表达式语句的限制。</p><p>函数的值和参数会按顺序在调用的 goroutine 中求值。不像普通的函数调用，程序不会等待函数调用完成，而是直接开启一个新的 goroutine 执行函数。函数退出时，goroutine 也会退出。函数的任何返回值都会被丢弃。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">go Server()go func(ch chan&lt;- bool) { for { sleep(10); ch &lt;- true }} (c)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="select-语句"><a href="#select-语句" class="headerlink" title="select 语句"></a>select 语句</h4><p>select 语句会在接收/发送操作集中选择一个执行。它看起来和 switch 很像，只不过是专门针对通信操作的。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">SelectStmt = "select" "{" { CommClause } "}" .CommClause = CommCase ":" StatementList .CommCase   = "case" ( SendStmt | RecvStmt ) | "default" .RecvStmt   = [ ExpressionList "=" | IdentifierList ":=" ] RecvExpr .RecvExpr   = Expression .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接收表达式可以将接收表达式的值分配给一个或两个变量。接收表达式必须是一个接收运算元（可以使用括号括起来）。它最多允许有一个 default 语句。</p><p>select 语句执行以下几个步骤：</p><ol><li><p>对于 select 语句的所有分句，接收操作的通道运算元、通道、发送语句的右侧表达式都会执行一次操作。</p></li><li><p>如果一个或多个通信同时发生，它会通过一致性随机选择一个执行。如果没有 default 语句，select 语句会一直阻塞。</p></li><li><p>除了 default 分句，其他分句只有在开始进行通信的时候才会执行。</p></li><li><p>如果 select 分句是一个接收语句，它可以给变量分配值。</p></li><li><p>执行 select 分句内的内容。</p></li></ol><p>如果向 nil 通道发送信息在没有 default 分句的情况下会一直阻塞。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">var a []intvar c, c1, c2, c3, c4 chan intvar i1, i2 intselect {case i1 = &lt;-c1:print("received ", i1, " from c1\n")case c2 &lt;- i2:print("sent ", i2, " to c2\n")case i3, ok := (&lt;-c3):  // same as: i3, ok := &lt;-c3if ok {print("received ", i3, " from c3\n")} else {print("c3 is closed\n")}case a[f()] = &lt;-c4:// same as:// case t := &lt;-c4//a[f()] = tdefault:print("no communication\n")}for {  // send random sequence of bits to cselect {case c &lt;- 0:  // note: no statement, no fallthrough, no folding of casescase c &lt;- 1:}}select {}  // block forever<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="return-语句"><a href="#return-语句" class="headerlink" title="return 语句"></a>return 语句</h4><p><code>return</code> 语句会终止函数 F 的执行并可选的返回一个或多个返回值。所有的滞后函数都会在 F 返回到它的调用者之前执行。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">ReturnStmt = "return" [ ExpressionList ] .<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果函数没有返回值类型，return 不能返回任何值。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func noResult() {return}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>有三种方式能够返回指定类型的值：</p><ol><li>返回值可以直接在 return 语句中列出。每个表达式都必须返回一个值并且能够分配给相应的返回值类型。</li></ol><pre class="line-numbers language-go" data-language="go"><code class="language-go">func simpleF() int {return 2}func complexF1() (re float64, im float64) {return -7.0, -4.0}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>return 语句的表达式列表可以是一个返回多值的函数调用。这时会使用临时变量来获取函数调用的返回值并直接将其作为 return 语句的表达式列表。</li></ol><pre class="line-numbers language-go" data-language="go"><code class="language-go">func complexF2() (re float64, im float64) {return complexF1()}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol><li>如果制定了返回值的标识符那么 return 的表达式列表可以为空。返回值参数会作为普通的本地变量按需分配。return 语句会直接返回它们。</li></ol><pre class="line-numbers language-go" data-language="go"><code class="language-go">func complexF3() (re float64, im float64) {re = 7.0im = 4.0return}func (devnull) Write(p []byte) (n int, _ error) {n = len(p)return}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不管如何声明，所有的返回值都会在进入函数前提前初始化成类型的零值。return 语句会在所有 defer 函数之前指定返回值。</p><p>实现限制：编译器不允许在覆盖了命名返回值的作用域中直接返回。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func f(n int) (res int, err error) {if _, err := f(n-1); err != nil {return  // invalid return statement: err is shadowed}return}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="break-语句"><a href="#break-语句" class="headerlink" title="break 语句"></a>break 语句</h4><p><code>break</code> 语句会在 <code>for</code>、<code>switch</code> 或 <code>select</code> 语句内部退出到相同函数的某个位置。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">BreakStmt = "break" [ Label ] .<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果想指定标签，它必须出现在它所中止的 <code>for</code>、<code>switch</code> 或 <code>select</code> 语句旁。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">OuterLoop:for i = 0; i &lt; n; i++ {for j = 0; j &lt; m; j++ {switch a[i][j] {case nil:state = Errorbreak OuterLoopcase item:state = Foundbreak OuterLoop}}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="continue-语句"><a href="#continue-语句" class="headerlink" title="continue 语句"></a>continue 语句</h4><p><code>continue</code> 语句会提前 <code>for</code> 语句的下一次迭代。<code>for</code> 语句必须和 <code>continue</code> 在相同函数中。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">RowLoop:for y, row := range rows {for x, data := range row {if data == endOfRow {continue RowLoop}row[x] = data + bias(x, y)}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="goto-语句"><a href="#goto-语句" class="headerlink" title="goto 语句"></a>goto 语句</h4><p><code>goto</code> 会将程序跳转到相同函数的指定标签处。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">GotoStmt = "goto" Label .<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">goto Error<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>goto 语句不允许跳过作用域内程序变量的初始化工作。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">goto L  // BADv := 3L:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上面的程序是错误的，因为它跳过了变量 v 的初始化过程。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">if n%2 == 1 {goto L1}for n &gt; 0 {f()n--L1:f()n--}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>标签作用域外的 goto 语句不能跳转到标签处，所以上面的代码是错误的。</p><h4 id="Fallthrough-语句"><a href="#Fallthrough-语句" class="headerlink" title="Fallthrough 语句"></a>Fallthrough 语句</h4><p><code>fallthrough</code> 语句会跳转到 <code>switch</code> 语句中的下一个 case 分句中。它应该只在最后一个非空分句中使用。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">FallthroughStmt = "fallthrough" .<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="Defer-语句"><a href="#Defer-语句" class="headerlink" title="Defer 语句"></a>Defer 语句</h4><p><code>defer</code> 语句会在包裹函数返回后触发函数调用。这里的返回泛指函数因为 return 语句终止、到达函数末尾或者当前 goroutine 触发运行时恐慌。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">DeferStmt = "defer" Expression .<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>表达式必须是函数或者方法调用；它不能使用括号括起来，调用内置函数会有一些限制。</p><p>每次执行 defer 语句执行时都会计算函数的参数和值，但是并不会调用函数。相反，函数的调用是在包裹函数返回后进行，它们的执行顺序与声明顺序正好相反。如果 defer 对应的函数值为 nil，会在调用函数的时候导致运行时恐慌而不是声明 defer 语句的时候。</p><p>例如：当 defer 函数为函数字面值且包裹函数具有命名结果值，此时，我们在defer 函数中可以访问和修改命名的结果值。defer 函数的所有返回值都会被忽略。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">lock(l)defer unlock(l)  // unlocking happens before surrounding function returns// prints 3 2 1 0 before surrounding function returnsfor i := 0; i &lt;= 3; i++ {defer fmt.Print(i)}// f returns 1func f() (result int) {defer func() {result++}()return 0}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h4><p>内置函数是预定义的。调用他们和其他函数一样只是他们接受一个类型而不是一个表达式。</p><p>内置函数没有标准的 Go 类型，所以他们只能作为调用表达式；而不能作为函数的值。</p><h6 id="Close"><a href="#Close" class="headerlink" title="Close"></a>Close</h6><p>对于管道类型 c，内置函数 <code>close(c)</code> 意味着不在有数据插入到管道中。如果 <code>c</code> 是一个只接收数据的管道，会发生错误。向已经关闭的发送数据或者重复关闭已经关闭的管道会导致运行时恐慌。关闭 nil 管道会引起运行时恐慌。调用 close 后所有之前发送的数据都能接收到，并且在最后不会阻塞而返回零值。多值的接收操作能够返回接收到的数据和表示管道是否关闭的布尔值。</p><h6 id="长度和容积"><a href="#长度和容积" class="headerlink" title="长度和容积"></a>长度和容积</h6><p>内置函数 <code>len</code> 和 <code>cap</code> 可以接收多种类型的参数，并且返回一个 int 类型结果值。函数的实现能够确保结果值不会溢出。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">Call      Argument type    Resultlen(s)    string type      string length in bytes          [n]T, *[n]T      array length (== n)          []T              slice length          map[K]T          map length (number of defined keys)          chan T           number of elements queued in channel buffercap(s)    [n]T, *[n]T      array length (== n)          []T              slice capacity          chan T           channel buffer capacity<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>切片的容积底层数组包含的元素个数。在任何情况下都有以下关系：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">0 &lt;= len(s) &lt;= cap(s)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>nil</code> 切片，map，或者 channel 的长度都为 0。<code>nil</code> 切片，管道的容积都为 0。</p><p>表达式 <code>len(x)</code> 在 <code>s</code> 是字符串常量时也为常量。如果 <code>s</code> 为数组或者指向数组的指针并且表达式 s 不包含 <code>channel</code> 接收器或者函数调用那么 <code>len(s)</code> 和 <code>cap(s)</code> 也是常量；在这个情况下 s 时不能求值的。其他情况下 <code>len</code> 和 <code>cap</code> 不是常量并且 <code>s</code> 是可以求值的。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">const (c1 = imag(2i)                    // imag(2i) = 2.0 is a constantc2 = len([10]float64{2})         // [10]float64{2} contains no function callsc3 = len([10]float64{c1})        // [10]float64{c1} contains no function callsc4 = len([10]float64{imag(2i)})  // imag(2i) is a constant and no function call is issuedc5 = len([10]float64{imag(z)})   // invalid: imag(z) is a (non-constant) function call)var z complex128<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h6><p>内置函数 <code>new</code> 接收一个类型 T，它会在运行时给变量分配内存，并且返回一个指向类型 <code>T</code> 的 <code>*T</code> 类型指针。变量的初始化在初始化值章节中介绍。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">new(T)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">type S struct { a int; b float64 }new(S)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>给 S 类型的变量分配空间，并初始化它（<code>a=0</code>，<code>b=0.0</code>），并且返回一个 <code>*S</code> 类型值保存变量所在的位置。</p><h6 id="创建切片，map-和-管道"><a href="#创建切片，map-和-管道" class="headerlink" title="创建切片，map 和 管道"></a>创建切片，map 和 管道</h6><p>内置函数 <code>make</code> 以一个类型作为参数，它必须是一个切片，map 或者管道类型，它返回一个 T 类型的值，而不是（*T）类型，它会按初始化值章节描述的方式进行初始化。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">Call             Type T     Resultmake(T, n)       slice      slice of type T with length n and capacity nmake(T, n, m)    slice      slice of type T with length n and capacity mmake(T)          map        map of type Tmake(T, n)       map        map of type T with initial space for approximately n elementsmake(T)          channel    unbuffered channel of type Tmake(T, n)       channel    buffered channel of type T, buffer size n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>n 和 m 必须是整数类型或者无类型常量。一个常量参数不能为负数并且该值在 <code>int</code> 类型的范围内；如果它是无类型常量，会被转换成 <code>int</code> 类型。如果 n 和 m 都是常量，那么 n 必须大于 m。如果 n 是负数或者大于 m 会引发运行时 panic。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">s := make([]int, 10, 100)       // slice with len(s) == 10, cap(s) == 100s := make([]int, 1e3)           // slice with len(s) == cap(s) == 1000s := make([]int, 1&lt;&lt;63)         // illegal: len(s) is not representable by a value of type ints := make([]int, 10, 0)         // illegal: len(s) &gt; cap(s)c := make(chan int, 10)         // channel with a buffer size of 10m := make(map[string]int, 100)  // map with initial space for approximately 100 elements<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 make 来指定大小初始化 map 类型将会创建一个预留 n 个元素空间的 map 类型。更详细的行为依赖于具体实现。</p><h6 id="追加或者拷贝切片"><a href="#追加或者拷贝切片" class="headerlink" title="追加或者拷贝切片"></a>追加或者拷贝切片</h6><p>内置函数 <code>append</code> 和 <code>copy</code> 可以进行切片的通用操作。对于这两个函数，一个是拷贝内存，一个是引用内存。</p><p>可变参数的函数 <code>append</code> 可以向切片 s 中追加一个或多个 x 值，并返回这个切片。传进 <code>...T</code> 的值会根据参数传值。作为特例，<code>append</code> 在 s 为 <code>[]byte</code> 切片时，可以使用字符串后面跟 <code>...</code> 作为参数。</p><p>如果 s 的容积容纳不下这些元素，那么 <code>append</code> 会分配一个新的足够大的数组。否则会使用原来的底层数组。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">s0 := []int{0, 0}s1 := append(s0, 2)                // append a single element     s1 == []int{0, 0, 2}s2 := append(s1, 3, 5, 7)          // append multiple elements    s2 == []int{0, 0, 2, 3, 5, 7}s3 := append(s2, s0...)            // append a slice              s3 == []int{0, 0, 2, 3, 5, 7, 0, 0}s4 := append(s3[3:6], s3[2:]...)   // append overlapping slice    s4 == []int{3, 5, 7, 2, 3, 5, 7, 0, 0}var t []interface{}t = append(t, 42, 3.1415, "foo")   //                             t == []interface{}{42, 3.1415, "foo"}var b []byteb = append(b, "bar"...)            // append string contents      b == []byte{'b', 'a', 'r' }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>copy</code> 函数从 <code>src</code> 拷贝原属到 <code>dst</code> 并且返回拷贝元素的个数。参数中所有的元素类型必须是 T 类型或者能转换成 T 的类型。拷贝元素的数量是 <code>len(src)</code> 和 <code>len(dst)</code> 中的较小值。作为特例，<code>copy</code> 可以从 string 类型拷贝元素到 <code>[]byte</code> 类型。这会把字符串中的元素拷贝到字节切片中。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">copy(dst, src []T) intcopy(dst []byte, src string) int<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>例：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">var a = [...]int{0, 1, 2, 3, 4, 5, 6, 7}var s = make([]int, 6)var b = make([]byte, 5)n1 := copy(s, a[0:])            // n1 == 6, s == []int{0, 1, 2, 3, 4, 5}n2 := copy(s, s[2:])            // n2 == 4, s == []int{2, 3, 4, 5, 4, 5}n3 := copy(b, "Hello, World!")  // n3 == 5, b == []byte("Hello")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="删除-map-中的元素"><a href="#删除-map-中的元素" class="headerlink" title="删除 map 中的元素"></a>删除 map 中的元素</h6><p>内置函数 <code>delete</code> 移除 map 类型 m 中的键值 k。k 的类型必须是能够转换成 m 键类型的类型。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">delete(m, k)  // remove element m[k] from map m<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果 map 类型 m 是 nil 或者 m[k] 不存在，那么 <code>delete</code> 函数不做任何事情。</p><h6 id="操作复数"><a href="#操作复数" class="headerlink" title="操作复数"></a>操作复数</h6><p>有三个函数可以组装或者分解复数。内置函数 <code>complex</code> 会构造一个复数，<code>real</code> 和 <code>imag</code> 会分解出复数的实部和虚部。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">complex(realPart, imaginaryPart floatT) complexTreal(complexT) floatTimag(complexT) floatT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>参数的类型和返回值类型是对应的。对于 <code>complex</code>，两个参数必须是相同的浮点类型，并返回由相同浮点数组成的复数类型。<code>complex64</code> 是 <code>float32</code> 对应的类型，<code>complex128</code> 是 <code>float64</code> 对应的参数类型。如果参数是一个无类型常量，它会转换成另一个参数的类型。如果两个参数都是无类型常量，他们必须实数或者虚数部分为零，并且它会返回一个无类型的复数常量。</p><p><code>real</code> 和 <code>imag</code> 函数和 <code>complex</code> 正好相反的，所以对于一个值复数类型 Z 的值 z，<code>z==Z(complex(real(z),imag(z)))</code>。</p><p>如果这么操作都是常量，那么返回的值也是常量。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">var a = complex(2, -2)             // complex128const b = complex(1.0, -1.4)       // untyped complex constant 1 - 1.4ix := float32(math.Cos(math.Pi/2))  // float32var c64 = complex(5, -x)           // complex64var s uint = complex(1, 0)         // untyped complex constant 1 + 0i can be converted to uint_ = complex(1, 2&lt;&lt;s)               // illegal: 2 assumes floating-point type, cannot shiftvar rl = real(c64)                 // float32var im = imag(a)                   // float64const c = imag(b)                  // untyped constant -1.4_ = imag(3 &lt;&lt; s)                   // illegal: 3 assumes complex type, cannot shift<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="处理-panic"><a href="#处理-panic" class="headerlink" title="处理 panic"></a>处理 panic</h6><p>两个内置函数 <code>panic</code> 和 <code>recover</code>，可以抛出和处理运行时 <code>panic</code> 和程序的错误条件。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func panic(interface{})func recover() interface{}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当执行 F 函数时，显式的调用 <code>panic</code>或者运行时 panic 都会中断 F 的执行。但是 F 中的延迟函数还会执行。接下来调用 F 函数处的延迟函数也会执行，一直到顶级的延迟函数。鉴于这点，程序关闭并且错误条件可以抛出。包括 <code>panic</code> 中的值。这个顺序叫做 <code>panicking</code>。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">panic(42)panic("unreachable")panic(Error("cannot parse"))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>recover</code> 函数允许程序从一个 panicking 中恢复执行。假设函数 G 延迟执行函数 D ，在 D 中调用 <code>recover</code> 这时如果在 G 执行时发生 panic 会在 D 中恢复。当函数执行到 D，<code>recover</code> 的返回值会返回 <code>panic</code> 对应的错误，并且终止 <code>panicking</code> 。在这个情况下 G 函数和 <code>panic</code> 之间的代码不会执行。任何在 D 中 G 之前的延迟函数会返回到调用者。</p><p>在下面两种情况下 <code>recover</code> 会返回 nil：</p><ul><li><p>panic 的参数为 nil</p></li><li><p>携程里没有发生 panic</p></li><li><p>recover 不是在延迟函数中执行</p></li></ul><p>本例中的 <code>protect</code> 函数会在 g 发生 panic 的时候恢复执行。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func protect(g func()) {defer func() {log.Println("done")  // Println executes normally even if there is a panicif x := recover(); x != nil {log.Printf("run time panic: %v", x)}}()log.Println("start")g()}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h6><p>这个实现提供了多个内置函数来帮助进行初始化。这些函数用来输出信息但是不确定会一直存在于语言中，他们都没有返回值。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">Function   Behaviorprint      prints all arguments; formatting of arguments is implementation-specificprintln    like print but prints spaces between arguments and a newline at the end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>实现限制：<code>print</code> 和 <code>println</code> 不接受除了布尔值，数字，字符串以外的其他类型。</p><h4 id="程序的初始化和执行"><a href="#程序的初始化和执行" class="headerlink" title="程序的初始化和执行"></a>程序的初始化和执行</h4><h6 id="零值"><a href="#零值" class="headerlink" title="零值"></a>零值</h6><p>当为变量分配内存空间时，不管是声明还是调用 <code>new</code> 或者使用字面值和 <code>make</code> 初始化，只要创建了一个新值变量都会有一个默认值。这样的元素和值会使用它类型的零值：<code>false</code> 是布尔值的零值，0 为数值类型零值，”” 为字符串零值，nil 为指针，函数，接口，切片，频道，字典。初始化会递归完成，所以结构体里的数组中的元素也都会有它自己的零值。</p><p>下面两个声明时相等的：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">var i intvar i int = 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>请看下面的声明：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">type T struct { i int; f float64; next *T }t := new(T)t.i == 0t.f == 0.0t.next == nil<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这和下面的声明时同等效果的：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">var t T<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h6 id="包的初始化"><a href="#包的初始化" class="headerlink" title="包的初始化"></a>包的初始化</h6><p>保级变量会按声明的顺序进行初始化，如果依赖其他变量，则会在其他变量之后进行初始化。</p><p>更确切的说，如果包级变量还没初始化并且没有初始化表达式或者表达式中不包含对其他未初始化变量的依赖，那么会认为它正在等待初始化。初始化过程会从最早声明的变量开始向下一个包级变量重复，直到没有需要初始化的变量。</p><p>如果在初始化过程完成后还有未初始化的变量，那么这些变量可能是循环初始化了，这事程序不是合法的。</p><p>在多个文件中变量的声明顺序会依据编译时文件出现的顺序：声明在第一个文件中的变量优先于第二个文件中声明的变量，依此类推。</p><p>对依赖关系的分析不会根据变量的具体值，它只分析在源码中是否引用了其他变量。例如，如果变量 x 的初始化表达式引用了变量 y 那么 x 就依赖于 y：</p><ul><li><p>引用一个变量或者函数中用到了一个变量</p></li><li><p>引用了一个方法值 <code>m</code> 或者方法表达式 <code>t.m</code> (这里的静态类型 <code>t</code> 不是借口类型，并且方法 <code>m</code> 是 <code>t</code> 方法集中的方法)。<code>t.m</code> 的返回值不会在此时影响。</p></li><li><p>变量，函数，或者方法 x 依赖变量 y</p></li></ul><p>依赖分析会在每个包中执行；他只考虑当前包中的析变量，函数，和方法。</p><p>例如，给定声明：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">var (a = c + bb = f()c = f()d = 3)func f() int {d++return d}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>初始化顺序为 d，b，c，a。</p><p>变量可以在包中声明的初始化函数 <code>init</code> 中进行初始化，它没有参数和返回值。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func init() {}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以为每个包定义多个该函数，甚至在一个文件中也可以。并且不会声明该该标识符。因此 init 函数不能在程序中调用。</p><p>还未导入的包会先初始化包级的变量然后按照 <code>init</code> 函数在源码中的顺序调用，它可能在包的多个文件中。如果需要导入一个包，它会在初始化自己之前先初始化这个需要导入的包。如果导入一个包多次，那这个包只会初始化一次。导入的包不能存在循环引用。</p><p>包的初始化——变量初始化和对 init 函数的调用会按顺序发生在同一个 goroutine 中。 <code>init</code> 函数可能会启动其他 goroutine。不过一般 <code>init</code> 函数都是按序进行初始化的：它只在上一步已经执行完成时才会调用下一个步骤。</p><p>确保初始化行为是可以复现的，构建系统鼓励在同一个包中包含多个文件这些文件在编译器中会以字母排序。</p><h6 id="程序执行"><a href="#程序执行" class="headerlink" title="程序执行"></a>程序执行</h6><p>一个完整的程序由一个 <code>main</code> 包导入所有需要的包。<code>main</code> 包必须以 <code>main</code> 作为包名并且声明一个没有参数和返回值的 <code>main</code> 函数。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>程序先初始化 <code>main</code> 包然后调用 <code>main</code> 函数。当 <code>main</code> 函数返回时，程序就会退出。它不会等待其他 goroutines 完成。</p><h4 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h4><p>预定义的错误类型为：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">type error interface {Error() string}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>它是表示错误信息的常规接口，nil 代表没有发生错误。例如，在文件中读取数据可以定义为：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func Read(f *File, b []byte) (n int, err error)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="运行时恐慌"><a href="#运行时恐慌" class="headerlink" title="运行时恐慌"></a>运行时恐慌</h4><p>运行时错误（例如数组的越界访问）会造成运行时恐慌，它和以 <code>runtime.Error</code> 接口实现调用内置的 <code>panic</code> 函数一样。<code>runtime.Error</code> 满足预定义的 <code>error</code> 接口。不同的错误值代表不同的运行时错误条件。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">package runtimetype Error interface {error// and perhaps other methods}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="系统相关"><a href="#系统相关" class="headerlink" title="系统相关"></a>系统相关</h4><h6 id="unsafe-包"><a href="#unsafe-包" class="headerlink" title="unsafe 包"></a>unsafe 包</h6><p><code>unsafe</code> 是编译器已知的内置包，可以通过导入路径 <code>unsafe</code> 访问包内容，提供 <code>unsafe</code> 包目的是支持底层编程（包括操作非 Go 类型的数据结构）。使用 <code>unsafe</code> 包必须自己保证类型安全而且它有可能破坏程序的移植性。<code>unsafe</code> 包提供了以下接口：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">package unsafetype ArbitraryType int  // 任意一个 Go 类型；它不是一个具体的类型。type Pointer *ArbitraryTypefunc Alignof(variable ArbitraryType) uintptrfunc Offsetof(selector ArbitraryType) uintptrfunc Sizeof(variable ArbitraryType) uintptr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Pointer</code> 是一个指针类型，但是不能解引用 <code>Pointer</code> 的值。所有底层类型 <code>uintptr</code> 的指针和值都能转换成 <code>Pointer</code> 类型，反之亦然。<code>Pointer</code> 和  <code>uintptr</code> 之间的转换效果由具体实现定义。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">var f float64bits = *(*uint64)(unsafe.Pointer(&amp;f))type ptr unsafe.Pointerbits = *(*uint64)(ptr(&amp;f))var p ptr = nil<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>假设变量 v 由 <code>var v = x</code> 定义。<code>Alignof</code> 以表达式 x 作为参数并返回 x 的对齐字节数。<code>Sizeof</code> 以表达式 x 作为参数并返回 x 的大小。</p><p>函数 <code>Offsetof</code> 以选择器 <code>s.f</code>（ s 或者 *s 结构体中的 f 字段）作为参数，返回字段相对结构体首地址的位置。如果 f 是一个嵌入字段，那 f 必须可以直接访问（不能通过指针进行间接访问）。对于结构体 s 的 f 字段：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">uintptr(unsafe.Pointer(&amp;s)) + unsafe.Offsetof(s.f) == uintptr(unsafe.Pointer(&amp;s.f))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>计算机的体系结构要求对齐内存地址（对于一个变量的地址有多种因素影响对齐）。<code>Alignof</code> 函数获取一个人和类型的表达式并返回变量对齐的字节数。对于变量 x：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">uintptr(unsafe.Pointer(&amp;x)) % unsafe.Alignof(x) == 0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编译时 <code>uintptr</code> 类型常量表达式会调用 <code>Alignof</code>，<code>Offsetof</code>，和 <code>Sizeof</code>。</p><h6 id="确定的大小和对齐字节数"><a href="#确定的大小和对齐字节数" class="headerlink" title="确定的大小和对齐字节数"></a>确定的大小和对齐字节数</h6><p>对于数字类型，确定有以下尺寸：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">type                                 size in bytesbyte, uint8, int8                     1uint16, int16                         2uint32, int32, float32                4uint64, int64, float64, complex64     8complex128                           16<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Go 中规定的最小对齐特性：</p><ol><li><p>对于任意变量类型 x：<code>unsafe.Alignof(x)</code> 至少为 1。</p></li><li><p>对于结构体类型：<code>unsafe.Alignof(x)</code> 是所有内部字段 <code>unsafe.Alignof(x.f)</code> 的最大值，并且至少为 1。</p></li><li><p>对于数组类型：<code>unsafe.Alignof(x)</code> 和数组元素类型的 alignment 相同。</p></li></ol><p>结构体（数组）在内部没有字段（元素）的时候大小为 0。两个所占空间大小为 0 的不同变量可能在内存中拥有相同地址。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="go" scheme="https://blog.xiaochong2021.top/categories/go/"/>
    
    
    <category term="go" scheme="https://blog.xiaochong2021.top/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>罗翔语录</title>
    <link href="https://blog.xiaochong2021.top/2021/10/21/luo-xiang-yu-lu/"/>
    <id>https://blog.xiaochong2021.top/2021/10/21/luo-xiang-yu-lu/</id>
    <published>2021-10-21T04:00:00.000Z</published>
    <updated>2021-10-24T09:30:15.119Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="演好自己的剧本"><a href="#演好自己的剧本" class="headerlink" title="演好自己的剧本"></a>演好自己的剧本</h2><h2 id="Keep-calm-and-carry-on"><a href="#Keep-calm-and-carry-on" class="headerlink" title="Keep calm and carry on."></a>Keep calm and carry on.</h2><pre class="line-numbers language-none"><code class="language-none">我们很多时候是不是觉得我们抓的牌实在是太差了呀但是再差的牌你都应该打下去我们登上并非我们所选择的舞台在坐的有谁的剧本是你自己设定的其实不是的 我们决定不了我们的出身我们决定不了我们的智商我们更决定不了我们这一生的贵人相助很多时候我们经常会羡慕别人的剧本我有的时候也非常羡慕别人的剧本但是没有谁的剧本值得羡慕你只能把你自己的剧本给演好如果在你的一生中真的遭遇到这些挫折那对不起 这就是你的剧本你有两种选择一种选择是弃演一种选择是把既定的剧本给选好 给演好所以希望大家能够演好自己的剧本摘自--罗翔<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="摘抄" scheme="https://blog.xiaochong2021.top/categories/%E6%91%98%E6%8A%84/"/>
    
    
    <category term="摘抄" scheme="https://blog.xiaochong2021.top/tags/%E6%91%98%E6%8A%84/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7.6进入单用户模式</title>
    <link href="https://blog.xiaochong2021.top/2020/12/01/centos7.6-jin-ru-dan-yong-hu-mo-shi/"/>
    <id>https://blog.xiaochong2021.top/2020/12/01/centos7.6-jin-ru-dan-yong-hu-mo-shi/</id>
    <published>2020-12-01T09:09:06.000Z</published>
    <updated>2020-12-01T09:17:33.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>-</p><p>CentOS7.6进入单用户模式</p><p>1、在启动grub菜单，选择编辑启动选项<br>2、按键盘e键，来进入编辑界面<br>3、找到Linux 16那行，将ro改为rw init=/sysroot/bin/sh<br>如果用的是kvm做了console连接授权，还要把授权的console=ttyS0去掉<br>4、按下 Control+x ，使用单用户模式启动<br>5、使用下面的命令访问系统<br>chroot /sysroot<br>6、重置密码<br>passwd root<br>7、更新系统信息（如果打开了selinux需要做这一步）<br>touch /.autorelabel<br>8、退出chroot<br>exit<br>9、重启系统<br>reboot</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="centos" scheme="https://blog.xiaochong2021.top/tags/centos/"/>
    
  </entry>
  
  <entry>
    <title>centos7的启动过程</title>
    <link href="https://blog.xiaochong2021.top/2020/11/01/centos7-de-qi-dong-guo-cheng/"/>
    <id>https://blog.xiaochong2021.top/2020/11/01/centos7-de-qi-dong-guo-cheng/</id>
    <published>2020-11-01T09:09:06.000Z</published>
    <updated>2020-11-01T09:17:33.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>centos7的启动过程</p><p>一、终端态启动顺序：</p><p>开机启过程<br>POST–&gt;BOOT<br>SEQUENCE–&gt;BOOTLOADER–&gt;KERNEL+INITRAMFS(INITRD)–&gt;ROOTFS–&gt;/sbin/init</p><p>POST:加电自检</p><p>检查内存，CPU等</p><p>Boot sequence：选择引导顺序</p><p>光盘启动，硬盘启动，网络启动，还是U盘启动(同windows)</p><p>Bootloader：引导加载器</p><p>MBR引导记录大小为512字节，其中前446个字节就是Bootloader,主要用来引导用户选择要启动的系统或不同的内核版本，把用户选定的内核装载到RAM中的特定空间中，解压，展开，而后把系统控制权移交给内核。</p><p>grub2分两部分：<br>1.在MBR引导记录中，大小为446字节，主要功能是引导启动介质的grub主体文件<br>2.partition,/boot/grub[2],此为grub的主体。</p><p>KERNEL+INITRAMFS(INITRD)–&gt;ROOTFS：加载内核</p><p>内核初始化，生成一个ramdisk文件，用来模拟系统环境。退出ramdisk,下一步加载到真正的根文件系统。</p><p>ramdisk：内存上临时虚拟的系统<br>ramdisk(虚拟磁盘，双缓冲，双缓存）—-&gt; ramfs（虚拟文件系统）<br>centos5:initrd</p><p>工具程序：mkinitrd</p><p>centos6,7:initramfs</p><p>工具程序：dracut,mkinitrd</p><p>/sbin/init：运行用户空间的第一个应用程序</p><p>init:</p><p>Centos 5: SysV init    配置文件：/etc/inittab<br>Centos 6: Upstart      配置文件：/etc/inittab;/etc/init/*.conf(主要）<br>Centos 7: systemd      配置文件：/etc/systemd/system;/usr/lib/systemd/system</p><p>至此，内核空间就已经启动完毕，内核启动完成接着开始启动用户态启动过程。<br>systemd是个守护进程，pid号为1,<br>后面所有启动的服务或进程都是systemd的子进程及子进程的子进程。</p><p>二、用户态的启动顺序</p><p>设置默认允许级别—&gt;初始化脚本，<br>完成系统初始化—&gt;关闭及启动对应级别下的服务—–&gt;设置登录终端—–&gt;[启动图形终端]</p><p>参考：<a href="https://blog.51cto.com/m51cto/1958856">https://blog.51cto.com/m51cto/1958856</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="centos" scheme="https://blog.xiaochong2021.top/tags/centos/"/>
    
  </entry>
  
  <entry>
    <title>改进CI管道中自动化性能测试的10条技巧（第1部分）</title>
    <link href="https://blog.xiaochong2021.top/2019/11/01/gai-jin-ci-guan-dao-zhong-zi-dong-hua-xing-neng-ce-shi-de-10-tiao-ji-qiao-di-1-bu-fen/"/>
    <id>https://blog.xiaochong2021.top/2019/11/01/gai-jin-ci-guan-dao-zhong-zi-dong-hua-xing-neng-ce-shi-de-10-tiao-ji-qiao-di-1-bu-fen/</id>
    <published>2019-11-01T09:17:05.000Z</published>
    <updated>2019-11-01T09:17:12.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="看一看如何通过连续测试和SLA改善CI管道的性能。"><a href="#看一看如何通过连续测试和SLA改善CI管道的性能。" class="headerlink" title="看一看如何通过连续测试和SLA改善CI管道的性能。"></a>看一看如何通过连续测试和SLA改善CI管道的性能。</h3><p><img src="https://dzone.com/storage/temp/12642760-10.jpg" alt="图片标题"></p><p><em>这是创建更好的CI管道的方法的1和2。</em></p><p>在持续集成管道中正确进行测试是Web规模软件开发的关键部分。对于许多公司而言，这是一个挑战，尤其是在自动化性能测试方面。这不是因为缺乏努力。许多公司似乎无法实现其努力的全部价值。原因很多。一些测试工作只是在重新发明轮子。其他人则只是出于执行目的而无明显意图地随机进行。确保测试既适当又旨在满足业务需求是事后才想到的。</p><p>不必一定是以这种方式。</p><p>任何公司都可以在自动化CI管道中进行有用，高效的性能测试。所需要的只是那些有知识的人的一些有用的知识。为了扩大“了解者”的圈子，我们创建了十个技巧列表，以改善CI Pipelines中的性能测试。</p><p>1.根据产品的长期目标进行连续测试</p><p>2.区分SLA，SLO和SLI</p><p>3.保持测试规模小且目标明确</p><p>4.在整体之前测试段</p><p>5.自动化不易碎的东西</p><p>6.节省时间，使用烟雾测试</p><p>7.利用您的源代码管理管理系统</p><p>8.没有反馈循环的期望不是</p><p>9.已知的基础架构是可测试的基础架构</p><p>10.使用您的CI / CD管道，而不是反对</p><p>今天的帖子将重点介绍前两个技巧，而其余建议将在单独的文章中介绍。</p><h2 id="1-根据产品的长期目标进行连续测试"><a href="#1-根据产品的长期目标进行连续测试" class="headerlink" title="1.根据产品的长期目标进行连续测试"></a><strong>1.根据产品的长期目标进行连续测试</strong></h2><p>如果你想快速识别什么可怕的事情是否在进行与贵公司的测试流程，请考虑以下情形。现在该发布产品了。开发团队中的每个人都以焦虑不安的状态坐在会议室的桌子旁，等待端到端测试完成，以便可以将代码推送发布。无论哪种方式，您都无法自拔。为什么？毕竟，如果测试顺利，代码将继续进行。没关系吧？错误。</p><p>发布的生存能力取决于单个引发焦虑的端到端测试的状态这一事实揭示了整个测试过程的重大缺陷。此类测试所承受的压力不应超过常规血液测试的压力。如果患者有定期体检，健康饮食和定期运动的病史，则血液检查应验证历史上的积极行为。但是，如果患者已经十年没有去看医生，只能依靠薯片和生啤酒的饮食生活，而且只能走到邮箱，那么简单的验血会改变您的生活。谁知道它可能揭示什么？</p><p>类比适用于IT流程。如果公司的总体开发实践是健康的，并且在软件开发生命周期的各个级别进行连续测试，则端到端测试应该只是另一个验证复选框。如果发现问题所在，则无需费力即可解决它。</p><p>当开发实践杂乱无章，而测试被拖到最后时，最后的端到端测试又怎会是一种焦虑的经历呢？谁知道代码中隐藏了多少技术债务，开发人员不再在公司工作留下了多少谜团。测试中有多少只不过是循环使用20％的代码库，而其余部分则保持不变？诸如此类的问题在开发环境中令人惊讶地普遍存在，在该环境中，长期产品目标尚不清楚，而测试事件则是偶然的。</p><p>当创造了所有人都可以充分理解长期产品目标的条件时，开发过程和所产生的代码质量也会提高（前提是在整个生命周期阶段都进行了连续测试）。基于产品的长期目标进行连续测试是明智且实用的，并有助于改善自动化性能测试。</p><h2 id="2-区分SLA，SLO和SLI"><a href="#2-区分SLA，SLO和SLI" class="headerlink" title="2.区分SLA，SLO和SLI"></a><strong>2.区分SLA，SLO和SLI</strong></h2><p>当大多数公司考虑定义软件/软件服务的工作方式时，他们相信服务水平协议。定义明确的SLA是必不可少的。否则，就没有可靠的方法让公司作为服务提供商或消费者运营。从提供商的角度来看，缺少SLA意味着客户可以随时（并期望）要求任何东西。从消费者的角度来看，没有SLA会使技术人员处于等待数小时的危险之中，因为他们的公司的数字基础架构崩溃时，他们一直处于等待与关键任务支持人员联系的状态。</p><p>SLA是必需的，但它们只能捕获部分图片。还需要更多。服务水平目标（SLO）和服务水平指标（SLI）的添加提供了必要的附加信息，以确保提供者和消费者之间的伙伴关系满足所有人的需求。</p><p>SLA描述了提供者和消费者之间的承诺；其复杂性将根据各方的需求而变化。SLA将定义每个服务的职责和服务的可用性。该协议仅取决于其背后目标的定义以及确定服务级别的度量标准。这就是SLO和SLI变得重要的地方。</p><p>如果提前定义了SLO，则建立SLA会容易得多。理解消费者希望从代码/服务中获得什么，将提供必要的见解，以确认所提供的服务符合期望。定义明确的SLO将有助于制定对所有人都有意义的SLA。</p><p>为了使SLA有效地满足SLO中规定的目标，必须定义一套标准的，易于理解的度量标准。否则，公司冒着将苹果与橙子进行比较的风险。因此，SLI的价值。服务水平指示器提供有关如何根据SLA衡量运营绩效的详细信息。SLI越精确，就越好。</p><p>SLO / SLI允许您根据SLA构造进行假设。确定了操作的需求和条件以及测量方法。“我需要喝点东西”和“我渴了，需要8盎司水来满足我的渴求”之间的区别。</p><p>然后，基于定义明确的SLO的SLA，然后根据详细SLI的一组度量标准进行测量，这将有益于常规操作以及测试过程。根据SLI中明确定义的参数，满足SLA要求的测试与即席测试相比，提供了更高的准确性和更可靠的分析。</p><p>在SLA，SLO和SLI之间进行区分将大大有助于在软件所涉及的各方（开发人员，测试人员和用户之间）之间建立有意义，可靠的关系。</p><p><em>下周，在由十个技巧组成的三部分博客系列中的第二篇中，我们将深入探讨技巧3-6。</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="自动化测试" scheme="https://blog.xiaochong2021.top/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>DevOps角色：您梦寐以求的工作是什么？</title>
    <link href="https://blog.xiaochong2021.top/2019/11/01/devops-jiao-se-nin-meng-mei-yi-qiu-de-gong-zuo-shi-shi-me/"/>
    <id>https://blog.xiaochong2021.top/2019/11/01/devops-jiao-se-nin-meng-mei-yi-qiu-de-gong-zuo-shi-shi-me/</id>
    <published>2019-11-01T09:09:06.000Z</published>
    <updated>2019-11-01T09:17:33.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="在DevOps环境中有很多可供选择的选择，每个人都可以找到一份工作。"><a href="#在DevOps环境中有很多可供选择的选择，每个人都可以找到一份工作。" class="headerlink" title="在DevOps环境中有很多可供选择的选择，每个人都可以找到一份工作。"></a>在DevOps环境中有很多可供选择的选择，每个人都可以找到一份工作。</h3><p><img src="https://dzone.com/storage/temp/12646937-blocks.jpg" alt="建筑模块"></p><p><em>有这么多DevOps角色可供选择，您将是哪个构建基块？</em></p><p>当IT专业人员迫切希望成为DevOps的专家时，对于各种DevOps角色还有很多困惑。因此，本文致力于使实施DevOps的公司的团队结构更加清晰。</p><p>您可能一直听说，在DevOps中，每个参与人员都扮演着共同的角色：DevOps，这是两种实践的结合：<em>Development</em>和<em>Operations</em>。但这远非事实。</p><h2 id="DevOps实践"><a href="#DevOps实践" class="headerlink" title="DevOps实践"></a><strong>DevOps实践</strong></h2><p>实际上，DevOps实践强调，开发人员应该能够执行由Ops家伙执行的任务，而Ops则应该能够执行由Dev家伙执行的任务。</p><p>既然您知道DevOps专业人员是具有多种技能的人员，那么您可能还想知道DevOps专业人员在其组织中负责的各种任务。如果是这样，请继续阅读。</p><p>要真正理解这个概念，您需要从另一个角度看待它。如果您置身于实施DevOps的公司中，那么它就更容易理解，因为您必须根据要求分配各种DevOps角色。</p><h2 id="DevOps角色"><a href="#DevOps角色" class="headerlink" title="DevOps角色"></a><strong>DevOps角色</strong></h2><p>首先让我列出各种角色及其描述。</p><ol><li><strong>DevOps传播者</strong> –负责实施DevOps的首席官（领导）</li><li><strong>发布管理器</strong> –发布新功能并确保发布后产品稳定性的工具</li><li><strong>自动化专家</strong> –负责实现工具自动化和编排的人</li><li><strong>软件开发人员/测试人员</strong> –实际开发代码并对其进行测试的人</li><li><strong>质量保证</strong> –确保产品质量符合其要求的人</li><li><strong>安全工程师</strong> –始终监视产品安全性和健康状况的<strong>工程师</strong></li></ol><p>这里要注意的重要一点是，其中许多角色将涉及一个团队或一组专业人员，例如软件开发人员/测试人员，安全工程师和质量保证。因此，您应该以层次结构的形式考虑这些角色及其关系。</p><p><img src="https://www.edureka.co/blog/wp-content/uploads/2018/02/DevOps-Roles.png" alt="DevOps角色"></p><p>根据公司的要求，甚至自动化专家也可以由多个人担任该角色。因此，让我更多地谈谈这些DevOps角色。</p><h3 id="DevOps传播者"><a href="#DevOps传播者" class="headerlink" title="DevOps传播者"></a><strong>DevOps传播者</strong></h3><p>就像我之前提到的那样，这是DevOps中的关键角色。由领导者或负责确保在产品的端到端开发中实施DevOps策略并带来环境积极影响的人员来担任此角色。</p><p>DevOps传播者还考虑到可用的各种自动化工具以及Dev和Ops团队具有的技能，还找到了改进产品现有体系结构的方法。他的主要目标是管理其他DevOps角色并从团队中获得全面的效率。</p><h3 id="发布经理"><a href="#发布经理" class="headerlink" title="发布经理"></a><strong>发布经理</strong></h3><p>该角色是产品可交付成果的关键角色，因为他需要将新功能/更新功能与现有框架集成在一起。该角色可以是担任发布工程师的角色的同一个人，也可以是领导发布工程师团队的发布经理。</p><p>该角色的主要重点领域是从开发到部署，以协调和管理产品。由于此角色是以重要方式参与的，因此应由了解该技术的工作原理和各种结构的技术人员（经理）来担任。</p><p>根据需求，将有多位经理领导各自的团队来处理多个功能（项目）。</p><h3 id="自动化专家"><a href="#自动化专家" class="headerlink" title="自动化专家"></a><strong>自动化专家</strong></h3><p>无需再次强调该角色的重要性，因为DevOps完全是关于自动化的。作为自动化专家，此角色应该能够理解什么可以自动化以及如何将一个产品堆栈与另一个产品堆栈集成。</p><p>此人也称为集成专家，负责分析，设计和实施持续部署的策略，同时确保生产和预生产系统的高可用性。</p><h3 id="软件开发人员-测试人员"><a href="#软件开发人员-测试人员" class="headerlink" title="软件开发人员/测试人员"></a><strong>软件开发人员/测试人员</strong></h3><p>该角色负责软件的实际根级开发。传统的编码人员和程序员属于这一类。除开发外，专业人员还负责测试代码。</p><p>名称可能保持不变，但是软件开发人员/测试人员的新角色大大增加了职责范围，因为他们不仅负责将新需求转化为代码，还负责单元测试，部署和持续监控。</p><h3 id="质量保证"><a href="#质量保证" class="headerlink" title="质量保证"></a><strong>质量保证</strong></h3><p>这是DevOps中引入的新角色，实际上可以保证产品的质量。通常也称为“体验保证”，此角色是传统测试和质量检查之外的一步。</p><p>在此，对产品的功能进行了极限测试，以发现每个缺陷并改善每个独立功能的性能欠佳，因为客户的经验至关重要。这个角色一直在寻找机会，以改善所有功能以提高客户满意度。</p><h3 id="安全工程师"><a href="#安全工程师" class="headerlink" title="安全工程师"></a><strong>安全工程师</strong></h3><p>安全工程师与任何其他角色一样重要，因为他们是负责监视产品交付能力的人员。他们与开发人员并肩工作，在过程中更早地嵌入了他们的建议（安全补丁）。</p><p>除了外部安全性之外，他们还监视系统以检查其性能，报告系统面临的任何停机时间并深入分析以找出造成该问题的原因。防止再次发生停机或安全风险是安全工程师的一项重要任务。</p><p>我希望到目前为止，您对组织中可能存在的各种DevOps角色有了很好的了解。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="devops" scheme="https://blog.xiaochong2021.top/tags/devops/"/>
    
  </entry>
  
  <entry>
    <title> 容器和配置：3个DevOps工具以及对应的速查表</title>
    <link href="https://blog.xiaochong2021.top/2019/10/15/rong-qi-he-pei-zhi-3-ge-devops-gong-ju-yi-ji-dui-ying-de-su-cha-biao/"/>
    <id>https://blog.xiaochong2021.top/2019/10/15/rong-qi-he-pei-zhi-3-ge-devops-gong-ju-yi-ji-dui-ying-de-su-cha-biao/</id>
    <published>2019-10-15T03:10:23.000Z</published>
    <updated>2019-10-15T03:24:17.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Puppet，Docker和Ansible速查表有助于简化DevOps的实现。"><a href="#Puppet，Docker和Ansible速查表有助于简化DevOps的实现。" class="headerlink" title="Puppet，Docker和Ansible速查表有助于简化DevOps的实现。"></a>Puppet，Docker和Ansible速查表有助于简化DevOps的实现。</h3><p><img src="https://dzone.com/storage/temp/12567617-tools.jpg" alt="工具"></p><p><em>这些DevOps工具使每个DevOps实施都更加容易。</em></p><h2 id="Puppet"><a href="#Puppet" class="headerlink" title="Puppet"></a><strong>Puppet</strong></h2><p>Puppet是使用最广泛的DevOps工具之一。它通过支持版本控制，自动测试和连续交付的功能，使交付和发布技术更改的速度更快，更频繁。它可以管理多台服务器并执行系统配置。出于多种原因，Puppet是当今IT行业中最流行的配置管理工具之一。</p><p>Puppet提供了更多的平台支持。例如，以下是您可以使用Puppet管理的平台：</p><ul><li>Debian / Ubuntu</li><li>Microsoft Windows</li><li>Redhat，Centos，Fedora</li><li>Mac OS X Server</li></ul><p>与其他配置管理工具不同，Puppet在任何系统上部署配置后，都会在一定间隔后继续验证那些配置。您也可以修改这些间隔。</p><h3 id="了解Puppet架构和Puppet组件"><a href="#了解Puppet架构和Puppet组件" class="headerlink" title="了解Puppet架构和Puppet组件"></a><strong>了解Puppet架构和Puppet组件</strong></h3><p><img src="https://dzone.com/storage/temp/12568247-how-does-puppet-work-1.png" alt="Puppet"></p><p><strong>Puppet Master：</strong> Puppet Master是处理所有与配置有关的信息的工具。Puppet Master在指定的服务器上运行，并管理部署和配置。</p><p><strong>Puppet Agent：</strong> Puppet代理在客户端上运行。Puppet代理是由Puppet Master维护和管理的实际工作机器。</p><p><strong>Config Repository：</strong> Config Repository是存储与服务器相关的配置和节点的位置。可以在需要时随时将其拉出。</p><p><strong>Facts</strong>：它们是全局变量，包含与机器有关的详细信息，例如操作系统和网络接口。它们用于分析任何节点的当前状态。</p><p><strong>Catalog</strong>：将用Puppet编写的所有配置都转换为编译后的格式，称为目录，然后将这些目录应用于目标系统。</p><p><strong>Manifests</strong>：清单是声明所有需要检查和更改的所有资源（即服务，程序包或文件）的文件。清单的扩展名为“ .pp”。</p><p><strong>Module</strong>：模块是清单文件的集合，这些清单文件的组织方式便于共享文件。</p><p><strong>Class</strong>：与其他编程语言一样，Puppet也具有用于更好地组织代码的类，从而使阅读和理解代码以及重用部分代码更加容易。</p><p><strong>Resources</strong>：在Puppet代码中，是通过声明资源定义的编码块，其中资源可以表示包，文件，用户，命令。</p><p><strong>Nodes</strong>：要在其上安装P代理的所有要管理的服务器或客户端都称为节点。</p><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a><strong>Docker</strong></h2><p>Docker是高端DevOps工具，它允许在多个系统上构建，交付和运行分布式应用程序。它有助于快速组装应用程序，通常适用于容器管理。</p><p>使用Docker容器时的一些重要术语包括：</p><ul><li><strong>Layer</strong>：只读文件以配置系统</li><li><strong>Image</strong>：只读层，它是镜像的基础</li><li><strong>Container</strong>：镜像的可运行实例</li><li><strong>Registry/hub</strong>: 镜像存放的中央位置</li><li><strong>Docker machine</strong>：运行Docker容器的虚拟机</li><li><strong>Docker-compose</strong>：一个虚拟机，可将多个容器作为系统运行</li></ul><p><img src="https://dzone.com/storage/temp/12568254-docker-cheat-sheet.jpg" alt="Docker速查表"></p><h2 id="Ansible"><a href="#Ansible" class="headerlink" title="Ansible"></a><strong>Ansible</strong></h2><p>Ansible是一种开源IT配置工具，可帮助自动执行服务器和云配置，配置管理和应用程序部署。它可以管理复杂的部署并提高生产率，并有助于自动化应用程序的整个生命周期。 </p><p>让我们考虑一种情况，其中系统管理员负责处理公司的基础结构。有九台服务器，其中五台服务器充当Web服务器，五台服务器充当数据库服务器。此外，您想在Web服务器上安装Tomcat，在数据库服务器上安装MySQL。在传统方法中，系统管理员将必须手动管理服务器，安装所需的软件并更改配置，以及分别管理每个服务器上的服务。Ansile通过自动执行此过程的大部分步骤来帮助解决这一问题。<br><img src="https://dzone.com/storage/temp/12568248-ansible-cheat-sheet-3.jpg" alt="Ansible速查表"></p><h3 id="Ansible中的重要术语"><a href="#Ansible中的重要术语" class="headerlink" title="Ansible中的重要术语"></a><strong>Ansible中的重要术语</strong></h3><p><strong>Controller Machine</strong>：这是Ansible的安装位置。控制器机器有助于在您管理的服务器上启用配置。</p><p><strong>Inventory</strong>：基本上，这是一个初始化文件，其中包含有关您所管理的服务器的信息。</p><p><strong>Playbook</strong>：脚本化的有组织的单位，用于定义服务器配置管理的自动化作业。</p><p><strong>Task</strong>：任务块定义了要在服务器上执行的单个过程，例如安装软件包。</p><p><strong>Nagios</strong>：此工具有助于监视IT基础结构。它能够确定错误并在标准网络，服务器和日志监视系统的帮助下进行纠正。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="devops" scheme="https://blog.xiaochong2021.top/tags/devops/"/>
    
  </entry>
  
  <entry>
    <title>将Python脚本变成漂亮的ML工具</title>
    <link href="https://blog.xiaochong2021.top/2019/10/08/jiang-python-jiao-ben-bian-cheng-piao-liang-de-ml-gong-ju/"/>
    <id>https://blog.xiaochong2021.top/2019/10/08/jiang-python-jiao-ben-bian-cheng-piao-liang-de-ml-gong-ju/</id>
    <published>2019-10-08T09:03:50.000Z</published>
    <updated>2019-10-08T09:03:50.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="将Python脚本变成漂亮的ML工具"><a href="#将Python脚本变成漂亮的ML工具" class="headerlink" title="将Python脚本变成漂亮的ML工具"></a>将Python脚本变成漂亮的ML工具</h2><p>Streamlit，这是专为ML工程师打造的应用程序框架<br>Adrien Treuille<br><img src="https://img.hacpai.com/file/2019/10/1Mbn2SxozueUkGKPW1NJkOw-342c5971.gif" alt="1Mbn2SxozueUkGKPW1NJkOw.gif"><br>在300行Python中使用实时神经网络推理对语义搜索引擎进行编码。</p><p>以我的经验，每个不平凡的机器学习项目最终都将使用漏洞缠身且无法维护的内部工具进行缝合。这些工具（通常是Jupyter笔记本和Flask应用程序的拼凑而成）难以部署，需要对客户端-服务器体系结构进行推理，并且无法与Tensorflow GPU会话等机器学习结构很好地集成。</p><p>我首先在卡内基·梅隆大学（Carnegie Mellon），然后在伯克利（Berkeley），谷歌X（Google X），以及后来在Zoox构建自动机器人时就看到了。这些工具通常是在Jupyter笔记本电脑中诞生的：传感器校准工具，模拟比较应用程序，LIDAR对准应用程序，场景重播工具等等。<br>随着工具重要性的提高，项目经理介入了。过程萌芽了。要求开花。这些单独的项目孕育成脚本，并逐渐成为繁琐的维护噩梦。</p><p><img src="https://img.hacpai.com/file/2019/10/15BWfcoBn2yypksY8QuKA-9aaa7cb1.png" alt="15BWfcoBn2yypksY8QuKA.png"><br>机器学习工程师的临时应用构建流程。</p><p>当工具变得至关重要时，我们召集了<strong>工具团队</strong>。他们写了流利的Vue和React。他们在笔记本电脑上贴上声明性框架的标签。他们有一个设计过程：</p><p><img src="https://img.hacpai.com/file/2019/10/1hNO5NYKjcsEV7jIpEaz8Eg-7c517413.png" alt="1hNO5NYKjcsEV7jIpEaz8Eg.png"><br>工具团队的应用程序构建流程整洁。</p><p>太棒了!但是这些工具都需要新功能，例如每周一次。工具团队正在支持其他十个项目。他们会说：“我们将在两个月内再次更新您的工具。”<br>因此，我们回到了构建自己的工具，部署Flask应用程序，编写HTML，CSS和JavaScript，以及尝试对从笔记本到样式表的所有内容进行版本控制的过程。因此，我的老Google X朋友Thiago Teixeira和我开始思考以下问题：<strong>如果我们能够使构建工具像编写Python脚本一样容易，该怎么办？</strong><br>我们希望机器学习工程师无需工具团队就能创建精美的应用程序。这些内部工具应作为ML工作流程的自然副产品而出现。写这样的工具应该感觉像训练神经网络或Jupyter执行即席分析！同时，我们希望保留功能强大的应用程序框架的所有灵活性。我们想要创建工程师可以炫耀的漂亮，高性能的工具。基本上，我们想要这样：</p><p><img src="https://img.hacpai.com/file/2019/10/1gdD55KRcRVRvfjsQLsXA-6c78e2d5.png" alt="1gdD55KRcRVRvfjsQLsXA.png"><br>Streamlit应用程序构建流程。</p><p>我们拥有一个了不起的Beta社区，其中包括来自Uber，Twitter，Stitch Fix和Dropbox的工程师，我们工作了一年的时间来创建Streamlit，这是一个针对ML工程师的完全免费和开源的应用程序框架。对于每个原型，Streamlit的核心原理变得越来越简单。他们是：<br><strong>＃1：拥抱Python脚本。</strong>Streamlit应用程序实际上只是从上到下运行的脚本。没有隐藏状态。您可以使用函数调用来分解代码。如果您知道如何编写Python脚本，则可以编写Streamlit应用程序。例如，这是您写入屏幕的方式：</p><pre class="line-numbers language-none"><code class="language-none">导入streamlit为st st.write（'Hello，world！'）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://img.hacpai.com/file/2019/10/1VNqEOqFJQl5fB7Z0ed5lMw-83fa2837.png" alt="1VNqEOqFJQl5fB7Z0ed5lMw.png"></p><p>很高兴见到你。<br><strong>＃2：将小部件视为变量。</strong>Streamlit中没有回调！每次交互都只是从上到下重新运行脚本。这种方法可以产生非常干净的代码：<br>导入streamlit为st </p><pre class="line-numbers language-none"><code class="language-none">x = st.slider（'x'）st.write（x，'squared is'，x * x）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://img.hacpai.com/file/2019/10/1h8BwonRrhnh3KtjO5cDEcA-0f122826.png" alt="1h8BwonRrhnh3KtjO5cDEcA.png"><br>包含三行代码的交互式Streamlit应用程序。</p><p><strong>＃3：重用数据和计算。</strong>如果您下载大量数据或执行复杂的计算该怎么办？关键是跨运行安全地重用信息。Streamlit引入了一种缓存原语，其行为类似于持久的默认情况下不可变的数据存储，可让Streamlit应用程序安全，轻松地重用信息。例如，此代码<strong>下载数据一次</strong>从Udacity自驾车项目，得到一个简单，快捷的应用程序：</p><pre class="line-numbers language-none"><code class="language-none">导入 streamlit as st将熊猫作为 pd 导入＃重复使用这些数据！read_and_cache_csv = st.cache（pd.read_csv）BUCKET  =  “ https://streamlit-self-driving.s3-us-west-2.amazonaws.com/ ”数据= read_and_cache_csv（BUCKET  +  “ labels.csv.gz ”，NROWS = 1000）wanted_label = st.selectbox（'过滤到：'，[ ' car '，' truck ' ]）st.write（数据[数据。标签==所需标签]）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原始代码查看：<a href="https://gist.github.com/treuille/c633dc8bc86efaa98eb8abe76478aa81/raw/2019640b6a9ff5da5ab6d5b11b3345ddc764b285/cache_example.py">https://gist.github.com/treuille/c633dc8bc86efaa98eb8abe76478aa81/raw/2019640b6a9ff5da5ab6d5b11b3345ddc764b285/cache_example.py</a></p><p>使用st.cache在Streamlit运行中保留数据。要运行此代码，请按照以下说明进行操作。</p><p><img src="https://img.hacpai.com/file/2019/10/1vLvk0xZUVEx1GcrzYhWxXQ-b58f56c0.png" alt="1vLvk0xZUVEx1GcrzYhWxXQ.png"></p><p>运行上面的st.cache示例的输出。</p><p>简而言之，Streamlit的工作方式如下：</p><ol><li>对于每个用户交互，整个脚本都是从头开始运行的。</li><li>Streamlit在给定小部件状态的情况下为每个变量分配一个最新值。</li><li>缓存允许Streamlit跳过冗余数据获取和计算。<br>或在图片中：<br><img src="https://img.hacpai.com/file/2019/10/1l4gxFYEZnRhysQQWIVJgA-afdf8c2f.png" alt="1l4gxFYEZnRhysQQWIVJgA.png"><br>用户事件触发Streamlit从头开始重新运行脚本。只有高速缓存在运行之间持续存在。</li></ol><p>如果这听起来很有趣，那么您可以立即尝试！赶紧运行：</p><pre class="line-numbers language-none"><code class="language-none">$ pip install --upgrade streamlit $ streamlit hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>   <pre class="line-numbers language-none"><code class="language-none">现在，您可以在浏览器中查看Streamlit应用程序。本地URL：http://localhost:8501 外网URL：http://10.0.1.29:8501<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这将自动弹出打开一个指向您本地Streamlit应用程序的Web浏览器。如果没有，只需单击链接。</p><p><img src="https://img.hacpai.com/file/2019/10/1Btm7O0pYqAkenXUPECLw-6ba5c610.png" alt="1Btm7O0pYqAkenXUPECLw.png"></p><p>要查看类似此分形动画的更多示例，请从命令行运行streamlit hello。</p><hr><p>好。你从分形玩回来了吗？这些可能会令人着迷。<br>这些想法的简单性不会阻止您使用Streamlit创建令人难以置信的丰富实用的应用程序。在Zoox和Google X期间，我看着无人驾驶汽车项目激增为数以十亿计的视觉数据，需要对其进行搜索和理解，包括在图像上运行模型以比较性能。我见过的每个自动驾驶汽车项目最终都让整个团队都在使用这种工具。<br>在Streamlit中构建这样的工具很容易。这个Streamlit演示使您可以在整个Udacity自动驾驶汽车照片数据集中执行语义搜索，可视化人类注释的地面真相标签，并从应用程序内部实时运行完整的神经网络（YOLO） [1]。<br><img src="https://img.hacpai.com/file/2019/10/1p3XPmx0TUIuMmQQa4mjHQ-81b29b26.gif" alt="1p3XPmx0TUIuMmQQa4mjHQ.gif"></p><p>这个300行的Streamlit演示结合了语义视觉搜索和交互式神经网络推理。</p><p>整个应用程序是一个完全自包含的300行Python脚本，其中大多数是机器学习代码。实际上，整个应用程序中只有23个Streamlit调用。您可以立即自己运行它！</p><pre class="line-numbers language-none"><code class="language-none">$ pip install --upgrade streamlit opencv-python $ streamlit runhttps://raw.githubusercontent.com/streamlit/demo-self-driving/master/app.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr><p>在与机器学习团队合作进行自己的项目时，我们意识到这些简单的想法产生了许多重要的好处：<br><strong>Streamlit应用程序是纯Python文件。</strong>因此，您可以在Streamlit中使用自己喜欢的编辑器和调试器。</p><p><img src="https://img.hacpai.com/file/2019/10/14KMALKoeS3TUSBn0ryzYg-d7bc9c09.png" alt="14KMALKoeS3TUSBn0ryzYg.png"></p><p>我最喜欢的用于编写Streamlit应用程序的布局在左侧是VSCode，在右侧是Chrome。</p><p><strong>纯Python脚本可与Git</strong>和其他源代码控制软件<strong>无缝配合</strong>，包括提交，拉取请求，问题和注释。因为Streamlit的基础语言是纯Python，所以您可以免费获得这些出色的协作工具的所有好处。</p><p><img src="https://img.hacpai.com/file/2019/10/0pY7e7BLPI2atTV-4bf401a4.png" alt="0pY7e7BLPI2atTV.png"></p><p>因为Streamlit应用程序只是Python脚本，所以您可以使用Git轻松地对其进行版本控制。</p><p><strong>Streamlit提供了即时模式实时编码环境。</strong>当Streamlit检测到源文件更改时，只需单击始终重新运行。</p><p><img src="https://img.hacpai.com/file/2019/10/1P3vtLkHGeCRHGu5B5ifg-0d278a81.png" alt="1P3vtLkHGeCRHGu5B5ifg.png"><br>单击“始终重新运行”以启用实时编码。</p><p><strong>缓存简化了计算管道的设置。</strong>令人惊讶的是，链接缓存的功能会自动创建高效的计算管道！考虑以下代码，这些代码是从我们的Udacity演示改编而成的：</p><pre class="line-numbers language-none"><code class="language-none">import streamlit as stimport pandas as pd@st.cachedef load_metadata():    DATA_URL = "https://streamlit-self-driving.s3-us-west-2.amazonaws.com/labels.csv.gz"    return pd.read_csv(DATA_URL, nrows=1000)@st.cachedef create_summary(metadata, summary_type):    one_hot_encoded = pd.get_dummies(metadata[["frame", "label"]], columns=["label"])    return getattr(one_hot_encoded.groupby(["frame"]), summary_type)()# Piping one st.cache function into another forms a computation DAG.summary_type = st.selectbox("Type of summary:", ["sum", "any"])metadata = load_metadata()summary = create_summary(metadata, summary_type)st.write('## Metadata', metadata, '## Summary', summary)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>源码来自：<a href="https://gist.github.com/treuille/ac7755eb37c63a78fac7dfef89f3517e/raw/568cc2d190c2f96b2a8a7aaf6fa444d68bde630e/caching_DAG_example.py">https://gist.github.com/treuille/ac7755eb37c63a78fac7dfef89f3517e/raw/568cc2d190c2f96b2a8a7aaf6fa444d68bde630e/caching_DAG_example.py</a></p><p>Streamlit中的简单计算管道。要运行此代码，请按照以下说明进行操作。<br>基本上，管道是load_metadata→create_summary。每次运行脚本时，<strong>Streamlit只会重新计算需要正确答案的管道子集。</strong>酷！</p><p><img src="https://img.hacpai.com/file/2019/10/1e0z12L0pXYlCE5OM3n6LA-7b6f242f.png" alt="1e0z12L0pXYlCE5OM3n6LA.png"><br>为了使应用程序具有高性能，Streamlit仅重新计算更新UI所需的任何内容。</p><p><strong>Streamlit是为GPU构建的。</strong>Streamlit允许直接访问机器级原语，例如TensorFlow和PyTorch，并补充了这些库。例如，在此演示中，Streamlit的缓存存储了整个NVIDIA名人GAN [2]。当用户更新滑块时，这种方法几乎可以实现瞬时推断。</p><p><img src="https://img.hacpai.com/file/2019/10/1188SkUE1onGcpQIuSZsiMQ-644dc8b5.gif" alt="1188SkUE1onGcpQIuSZsiMQ.gif"><br>该Streamlit应用程序使用管韶博的TL-GAN [3] 演示了NVIDIA名人GAN [2]模型。</p><p><strong>Streamlit是一个免费的开源库，而不是专有的Web应用程序。</strong>您可以在不与我们联系的情况下在本地提供Streamlit应用程序。您甚至可以在没有Internet连接的笔记本电脑上本地运行Streamlit！此外，现有项目可以逐步采用Streamlit。</p><p><img src="https://img.hacpai.com/file/2019/10/1nyOMWYNcM9mPTU5mHf1CxQ-fa82969b.png" alt="1nyOMWYNcM9mPTU5mHf1CxQ.png"><br>有几种方法逐渐采用Streamlit。（图标由fullvector / Freepik提供。）<br>这只是您使用Streamlit可以做的事情的表面。</p><p>Streamlit最令人兴奋的方面之一是如何将这些原语轻松地组合成看起来像脚本的复杂应用程序。关于我们的架构如何工作以及我们计划的功能，我们还有很多话要说，但是我们将其保存下来以备将来之用。</p><p><img src="https://img.hacpai.com/file/2019/10/1wmwwsWkOHzsYLe8pB2RzBA-33e9fe5c.png" alt="1wmwwsWkOHzsYLe8pB2RzBA.png"><br>Streamlit组件的框图。更多即将推出！</p><p>我们很高兴能最终与社区今天共享Streamlit，并看到你们所有人用它构建的东西。我们希望您会发现将Python脚本转换为漂亮的ML应用变得轻松而愉快。</p><p>感谢Amanda Kelly，Thiago Teixeira，TC Ricks，Seth Weidman，Regan Carey，Beverly Treuille，GenevièveWachtell和Barney Pell在本文中提供的有益帮助。</p><p>参考文献：<br>[1] J. Redmon and A. Farhadi, *YOLOv3: An Incremental Improvement *(2018), arXiv.<br>[2] T. Karras, T. Aila, S. Laine, and J. Lehtinen, <em>Progressive Growing of GANs for Improved Quality, Stability, and Variation</em> (2018), ICLR.<br>[3] S. Guan, *Controlled image synthesis and editing using a novel TL-GAN model *(2018), Insight Data Science Blog.</p><p>感谢TC Ricks ，Amanda Kelly 和Amanda Kelly 。 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="机器学习" scheme="https://blog.xiaochong2021.top/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>如何为DevOps的面试做好充分准备</title>
    <link href="https://blog.xiaochong2021.top/2019/09/24/ru-he-wei-devops-de-mian-shi-zuo-hao-chong-fen-zhun-bei/"/>
    <id>https://blog.xiaochong2021.top/2019/09/24/ru-he-wei-devops-de-mian-shi-zuo-hao-chong-fen-zhun-bei/</id>
    <published>2019-09-24T04:43:37.000Z</published>
    <updated>2019-09-24T04:43:37.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="这是您为DevOps热点准备的面试准备。"><a href="#这是您为DevOps热点准备的面试准备。" class="headerlink" title="这是您为DevOps热点准备的面试准备。"></a>这是您为DevOps热点准备的面试准备。</h3><p><img src="https://dzone.com/storage/temp/12433224-interiew-chairs-and-table.jpg" alt="面试桌椅"></p><p><em>那么，为什么他们要雇用您呢？</em></p><p>在过去的十年中，DevOps成为一种新的技术文化和职业，将软件开发所需的快速迭代与基础架构运营团队的坚如磐石的稳定性相结合。对于系统管理员，运营工程师以及其他拥有强大系统和软件背景的人员来说，过渡到DevOps的时间可能比现在更好。截至2019年8月，仅在美国，目前就有超过50,000个 LinkedIn DevOps工作岗位。</p><p>假设您已经了解了基础知识，并准备开始寻找工作。您如何评价DevOps面试？DevOps工程师必须既是优秀的软件开发人员，又是基础架构专家，因此，他们应该知道Linux基础架构，网络，算法和DevOps工具（例如Terraform，Docker和Kubernetes）。范围从标准软件工程师编码问题到有关系统设计，再到Linux调试和DevOps工具的问题等等。</p><p>这是一个令人生畏的清单，但请不要害怕！在Insight上，DevOps奖学金将许多具有可转让技能的个人的职业推向了人们所期望的行业DevOps职位。这是我们为他们准备面试的方式。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>动机是一个好的开始，但是您需要纪律才能有效地做好准备。我编写了这本指南，以帮助您制定有规律的面试准备程序。面试真的很烂-这是随机的，可能会让您对自己感到难过。在此过程中，<strong>不可</strong>控制的事情太多了，但是您<strong>可以</strong>控制自己的准备方式。</p><p>在这里有很多值得一试的东西，所以不要指望能够一次学习所有东西。也许有一天您会选择一个主题来关注。也许您将连续一个星期专注于另一个主题。不过，通常来说，您应该每天习惯性地进行两到三项活动，轮流讨论不同的主题，以使您的思想保持新鲜和投入。这些类别按重要性顺序列出：</p><ol><li>Linux基础</li><li>数据结构与算法</li><li>系统设计</li><li>解析</li><li>DevOps工具</li></ol><p>首先，要建立广泛而浅薄的知识基础，这样一来，以循环方式首先在各个主题之间实现负载平衡是一件好事。这将扩大您的DevOps空间的概念框架，以便您可以更轻松地将新信息放入上下文中。每个类别中的活动也按重要性顺序或多或少地排名。某些活动适合日常实践，例如CodeSignal问题或OverTheWire挑战。其他人则适合深入学习。</p><p>如果您想快点走，那就一个人走。但是，如果您想走得更远，那就一起走吧。与您的同龄人一起创建一个学习小组。互相追究责任。每周或每天签到和信息共享会话。在这段时间里，您会感到无动力，请记住，做某事总比什么都不做好。在您动力十足的那段时间里，请记住，睡眠和运动对您的成功至为重要。这些活动是人生下一阶段的垫脚石，但请记住让自己着迷于每块石头的形状。</p><h2 id="Linux基础"><a href="#Linux基础" class="headerlink" title="Linux基础"></a>Linux基础</h2><p>作为一名DevOps工程师，你应该对Linux了如指掌。从内核到网络再到命令行命令，有关Linux的任何问题都是公平的游戏。</p><h3 id="示例问题"><a href="#示例问题" class="headerlink" title="示例问题"></a>示例问题</h3><ul><li>Linux计算机加电时发生的步骤顺序是什么？</li><li>当您在浏览器中键入google.com并导致网页返回给您时，会发生什么情况？如果没有出现网页怎么办？如何调试问题？</li><li>您如何检查文件系统是否空间不足？如何打印最大文件列表？如何删除所有大于1 GB的.mov文件？</li></ul><h3 id="活动"><a href="#活动" class="headerlink" title="活动"></a>活动</h3><ul><li>通读<a href="http://solutionsproj.net/software/The_Linux_Command_Linex.pdf"><em>Linux命令</em></a>行书</li><li>通过<a href="https://overthewire.org/wargames/">OverTheWire</a>战争游戏进行工作。这些是通过精心设计的Linux系统进行的有趣的寻宝游戏，旨在教您一些基本概念。至少通过强盗等级。如果遇到困难，请不要担心Google解决方案。我强烈建议您随时随地在GitHub中记录进度。</li><li>只需使用vimtutor命令来学习vim。它是有史以来最好的编辑器，请勿让任何人说服您。</li><li>考虑购买课程以获取Linux基础知识认证（Linux +，RedHat等）。的确，一磅的认证比一盎司的经验没有价值，但是，如果您经验不足，那么认证可以帮助填补您的知识空白，并证明您具有基本的了解。</li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li>最好参考手册Linux命令是<a href="https://tldr.sh/">tldr.sh</a>。我强烈建议您下载tl; dr移动应用程序以快速参考。这在电话采访中帮助了我，我当时根本不知道该怎么做。</li><li><a href="https://devhints.io/">devhints.io</a>是各种备忘单的重要来源。</li><li>它看上去并不浮华，但是<a href="https://www.tldp.org/LDP/abs/html/">Advanced Bash脚本指南</a>是个巨大的财产库。</li></ul><h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><p>请记住，DevOps是<strong>开发</strong> +运营，因此您应该知道如何编码。选择一种您选择的语言（不是Bash-如果您不太喜欢，我建议使用Python）并练习，练习，练习。这不仅仅是寻找最佳解决方案-您必须与面试官清楚地交流问题的参数，传达您的思考过程，并计算不同算法的时间和空间复杂度。</p><h3 id="示例问题-1"><a href="#示例问题-1" class="headerlink" title="示例问题"></a>示例问题</h3><ul><li>从列表中删除所有重复项。</li><li>在包含除一个以外的所有可能IP的文件中找到丢失的IP。</li><li>对二叉树的所有节点进行排序。</li></ul><h3 id="活动-1"><a href="#活动-1" class="headerlink" title="活动"></a>活动</h3><ul><li><a href="https://www.khanacademy.org/computing/computer-science/algorithms">可汗学院</a>有一个非常好的数据结构和算法入门。它使用Javascript，但不要反对它。该课程是与汤姆·科门（Tom Cormen）合作完成的，汤姆·科门（Tom Cormen）是<a href="https://en.wikipedia.org/wiki/Introduction_to_Algorithms">一本有关数据结构和算法</a>的权威<a href="https://en.wikipedia.org/wiki/Introduction_to_Algorithms">著作</a>，绝对值得拥有。</li><li><a href="https://leetcode.com/">LeetCode</a>拥有大量的问题库，这些问题库与真实的面试问题非常接近。实际上，许多公司都会直接问您LeetCode问题！每种算法至少要回答10个简单和中等问题。当您解决了100个问题后，您就可以开始感到准备好了，并且实际上可以解决这些问题而无需查找任何内容。</li><li>每天在<a href="https://codesignal.com/developers/interview-practice/">CodeSignal</a>上<a href="https://codesignal.com/developers/interview-practice/">完成</a>面试准备材料。我建议使用Python，但您可以使用任何语言。将代码复制并粘贴到文件中，并使用Gi​​tHub对其进行版本控制。每天，仔细阅读您昨天做的代码，并详细记录下来。编写代码比阅读旧代码并记住发生的事情要容易。一两天后重新访问旧代码将迫使您综合所学的概念。</li><li>通过CodeSignal的Python Arcade进行工作。这是对所有重要的标准Python库的很好的浏览。有些练习确实没有达到目标，但总体而言，这是一个不错的播放列表。</li><li>研究动态规划，有向无环图，拓扑排序。</li><li>每个人都需要一点SQL。无需花费大量时间，但是您应该在<a href="https://mode.com/">Mode Analytics</a>上注册一个免费帐户，并利用其使用真实公共数据库的出色互动SQL教程。</li><li>随着您对编码技能的适应程度提高，请使用<a href="https://www.pramp.com/">Pramp</a>进行现场技术面试。这是重要的组成部分。像练习技术电话屏幕一样，您没有比技术电话屏幕更充分的准备。</li><li>请记住，唯一有价值的知识是您可以在白板或实时编码上在面试官面前展示的内容。如果您倾向于在高压情况下停滞不前，那么您就远非唯一的人了-请确保与同伴一起做很多练习。</li></ul><h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://learnxinyminutes.com/docs/python3/">LearnXinYminutes</a>是一个很棒的示例驱动的Python备忘单</li><li><a href="https://gto76.github.io/python-cheatsheet/#main">Python</a>备忘<a href="https://gto76.github.io/python-cheatsheet/#main">单</a>：最好的Python备忘单，尽管它很简洁</li><li><a href="https://docs.python-guide.org/">Hitchhiker的Python指南</a>：最佳的Python文档。</li><li>我的<a href="https://github.com/chuckinator0/Projects/tree/master/scripts">脚本GitHub存储库中</a>有很多示例文件，这些文件经过了详细记录，尽管实际上是无组织的！</li></ul><h2 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h2><p>系统设计面试可测试您的整体思维，架构复杂基础架构的能力以及沟通技巧。确保采用自上而下的设计方法，并具有清晰的基础结构图和DevOps注意事项。</p><h3 id="示例问题-2"><a href="#示例问题-2" class="headerlink" title="示例问题"></a>示例问题</h3><ul><li>设计一个基于微博消息的社交网络，如Twitter。您将如何确保不同地区的高可用性？</li></ul><h3 id="活动-2"><a href="#活动-2" class="headerlink" title="活动"></a>活动</h3><ul><li>消除<a href="https://github.com/donnemartin/system-design-primer/blob/master/README.md">系统设计入门知识</a>。一个有趣的事情是选择一个主题，然后请朋友选择另一个主题，然后花2个小时研究您的主题，然后再花一两个小时进行分享。轮流扮演面试官和受访者的角色。</li><li>阅读<a href="https://landing.google.com/sre/sre-book/toc/index.html">Google SRE图书</a>。这是现代DevOps必读的书。</li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>系统管理员经常分析系统输出和日志，以获得系统见解和调试问题。使用grep，awk和sed之类的工具进行命令行解析是DevOps工具库的一项重要技能。</p><h3 id="示例问题-3"><a href="#示例问题-3" class="headerlink" title="示例问题"></a>示例问题</h3><ul><li>给定一个Apache Web服务器日志，每天有多少个请求？哪些IP是最常访问的访客？最需要哪些页面和图像？</li></ul><h3 id="活动-3"><a href="#活动-3" class="headerlink" title="活动"></a>活动</h3><ul><li>通过Insight的<a href="https://github.com/InsightDataScience/Parsing-Workshop">解析研讨会资料</a>中的<strong>练习进行练习</strong>。专注于awk。本章材料不错，是练习是最重要的部分。<a href="https://github.com/InsightDataScience/Parsing-Workshop"></a></li></ul><h3 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://learnxinyminutes.com/docs/awk/">LearnXinYminutes</a>：另一个出色的示例驱动参考-这次是awk。</li><li><a href="https://regexr.com/">Regexr</a>：最佳正则表达式参考。</li></ul><h2 id="DevOps工具"><a href="#DevOps工具" class="headerlink" title="DevOps工具"></a>DevOps工具</h2><p>Docker，Terraform和Kubernetes是必不可少的DevOps工具，并且彻底学习它们不会出错。您还应该知道至少一种CI/CD工具，例如Jenkins。强烈建议您至少在三大云之一上学习这些工具：AWS，GCP或Azure。</p><h3 id="示例问题："><a href="#示例问题：" class="headerlink" title="示例问题："></a>示例问题：</h3><ul><li>使用Terraform将Docker应用程序部署到新的AWS EC2实例上。</li></ul><h3 id="活动-4"><a href="#活动-4" class="headerlink" title="活动"></a>活动</h3><ul><li>您需要学习Kubernetes。为了学习Kubernetes，您需要了解容器化和Docker。</li><li>通过<a href="https://github.com/docker/labs/blob/master/beginner/readme.md">Docker初学者</a>实验</li><li>通过<a href="https://training.play-with-docker.com/">Docker课堂</a>进行<a href="https://training.play-with-docker.com/">游戏</a></li><li>Kubernetes（概念：容器编排）</li><li>阅读<a href="https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/">Kubernetes概念</a></li><li>通过<a href="https://kubernetes.io/docs/tutorials/kubernetes-basics/">Kubernetes基础</a>教程学习</li><li>若要进行更深入的潜水，请完成<a href="https://www.katacoda.com/courses/kubernetes">Katacoda课程</a></li><li>通过一两个入门性的<a href="https://jenkins.io/doc/tutorials/build-a-python-app-with-pyinstaller/">Jenkins教程</a>来学习有关CI / CD的更多信息（概念：部署管道作为代码）。老实说，我对Jenkins知之甚少，所以我不了解更好的资源。</li><li>使用<a href="https://www.vagrantup.com/intro/getting-started/index.html">Vagrant</a>声明性地定义VM，然后使用<a href="https://www.virtualbox.org/">VirtualBox</a>或<a href="https://www.packer.io/intro/getting-started/install.html">Packer</a>将该VM导出为OVA文件（概念：不可变的基础结构，配置为代码）。</li><li>Terraform（概念：基础架构作为代码）</li><li>阅读Terragrunt的<a href="https://blog.gruntwork.io/a-comprehensive-guide-to-terraform-b3d32832baca">Terraform综合指南</a></li><li>通过<a href="https://learn.hashicorp.com/terraform/">Terraform教程进行工作</a></li><li>Ansible（概念：配置为代码）</li><li>观看<a href="https://www.ansible.com/resources/videos/quick-start-video">介绍视频</a></li><li>对于一些动手实验，我认为Linux Academy可能是最好的选择（不是免费的）</li><li>进行<a href="https://docs.honeycomb.io/learning-about-observability/quick-start/">Honeycomb Quickstart，</a>以提供一种监视/跟踪工具（概念：全栈跟踪）</li><li>完成<a href="https://learn.hashicorp.com/consul/">Consul教程</a>（概念：服务发现）。</li><li>完成<a href="https://learn.hashicorp.com/vault/">Vault教程</a>（概念：企业级机密管理）</li><li>玩<a href="https://linkerd.io/2/getting-started/">Linkerd</a>（概念：服务网格）</li><li>Apache Kafka（概念：容错，高吞吐量事件流）</li><li>适用于Apache Kafka的无耻插件—  在该网站上免费找到<a href="https://cloud.contentraven.com/confluent/self-userpackage">Confluent培训</a>课程，以获取有关Kafka基础知识的不错的视频集</li><li>查看<a href="https://github.com/confluentinc/training-operations-src">操作培训仓库，</a>以建立自己的本地docker-组成Kafka集群，并开始使用Kafka</li></ul><h3 id="参考-3"><a href="#参考-3" class="headerlink" title="参考"></a>参考</h3><ul><li>Ansible：<a href="https://docs.ansible.com/ansible/latest/user_guide/index.html">用户指南</a>。</li><li>想在Kubernetes中做一些特定的事情吗？检查文档的“ <a href="https://kubernetes.io/docs/tasks/">任务”</a>部分。有许多特定于任务的指南。</li><li>Docker的“demo”(<a href="https://docs.docker.com/samples/)%E9%A1%B5%E9%9D%A2%E6%8F%90%E4%BE%9B%E4%BA%86%E5%AE%8C%E6%95%B4%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%89%AF%E5%A5%BD%E7%A4%BA%E4%BE%8B%E4%BB%A5%E5%8F%8A%E4%B8%80%E4%BA%9B%E5%AE%9E%E7%94%A8%E7%9A%84%E6%95%99%E7%A8%8B%E3%80%82%E6%88%91%E5%96%9C%E6%AC%A2[Django">https://docs.docker.com/samples/)页面提供了完整应用程序的良好示例以及一些实用的教程。我喜欢[Django</a> + Postgres](<a href="https://docs.docker.com/compose/django/)%E7%A4%BA%E4%BE%8B%E3%80%82">https://docs.docker.com/compose/django/)示例。</a></li></ul><h2 id="其他具有高价值物品"><a href="#其他具有高价值物品" class="headerlink" title="其他具有高价值物品"></a>其他具有高价值物品</h2><h3 id="活动-5"><a href="#活动-5" class="headerlink" title="活动"></a>活动</h3><ul><li>定期收听《软件工程日报》(<a href="https://softwareengineeringdaily.com/)%E6%92%AD%E5%AE%A2%E3%80%82%E5%88%B0%E7%9B%AE%E5%89%8D%E4%B8%BA%E6%AD%A2%EF%BC%8C%E8%BF%99%E6%98%AF%E4%BF%9D%E6%8C%81DevOps%E4%B8%96%E7%95%8C%E8%84%89%E6%90%8F%E7%9A%84%E6%9C%80%E4%BD%B3%E6%96%B9%E6%B3%95%E3%80%82%E5%BB%BA%E8%AE%AE%E6%82%A8%E5%AE%89%E8%A3%85%E8%AF%A5%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%EF%BC%8C%E4%BB%A5%E4%BE%BF%E6%82%A8%E5%8F%AF%E4%BB%A5%E8%BD%BB%E6%9D%BE%E6%90%9C%E7%B4%A2%E6%97%A7%E5%89%A7%E9%9B%86%EF%BC%8C%E4%BB%A5%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E6%AD%A3%E5%9C%A8%E7%A0%94%E7%A9%B6%E7%9A%84%E6%8A%80%E6%9C%AF%E5%92%8C%E6%A6%82%E5%BF%B5%E3%80%82%E5%9C%A8%E2%80%9C">https://softwareengineeringdaily.com/)播客。到目前为止，这是保持DevOps世界脉搏的最佳方法。建议您安装该应用程序，以便您可以轻松搜索旧剧集，以深入了解正在研究的技术和概念。在“</a> DevOps工具”部分中，我为每个工具背后的概念提供了关键字。您可以使用这些关键字在SEdaily中搜索相关的播客。</li><li>阅读有关看板(<a href="https://www.atlassian.com/agile/kanban/boards)%E7%9A%84%E7%9F%A5%E8%AF%86%EF%BC%8C%E5%B9%B6%E4%BD%BF%E7%94%A8%E5%AE%83%E4%BB%AC%E6%9D%A5%E5%A2%9E%E5%BC%BA%E6%82%A8%E7%9A%84%E6%B3%A8%E6%84%8F%E5%8A%9B%E5%92%8C%E7%94%9F%E4%BA%A7%E5%8A%9B%E3%80%82GitHub%E6%9C%89%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%9C%8B%E6%9D%BF%EF%BC%8C%E6%82%A8%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%AE%83%E6%9D%A5%E4%BF%9D%E6%8C%81%E7%94%9F%E4%BA%A7%E5%8A%9B%E3%80%82%E6%88%91%E4%B8%AA%E4%BA%BA%E4%B9%9F%E5%96%9C%E6%AC%A2[%E5%AD%90%E5%BC%B9%E5%BC%8F%E6%97%A5%E8%AE%B0](https://www.youtube.com/watch?v=fm15cmYU0IM)%E5%92%8C%5BPomodoro%E6%96%B9%E6%B3%95%5D(https://en.wikipedia.org/wiki/Pomodoro_Technique)%E3%80%82">https://www.atlassian.com/agile/kanban/boards)的知识，并使用它们来增强您的注意力和生产力。GitHub有一个简单的看板，您可以使用它来保持生产力。我个人也喜欢[子弹式日记](https://www.youtube.com/watch?v=fm15cmYU0IM)和[Pomodoro方法](https://en.wikipedia.org/wiki/Pomodoro_Technique)。</a></li><li>深入了解一些您喜欢的工具的技术细节。从文档开始。配对并分享技术深层次的收获。</li><li>考虑为Linux Academy或acloudguru课程付费以获得AWS，GCP或Azure认证。</li></ul><h3 id="参考-4"><a href="#参考-4" class="headerlink" title="参考"></a>参考</h3><ul><li>Digital Ocean有很棒的教程。当我使用Google时，我倾向于首先尝试“ <research topic=""> site：digitalocean.com”。当您第一次学习手动安装某些东西时，这特别有用。</research></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="DevOps" scheme="https://blog.xiaochong2021.top/tags/DevOps/"/>
    
    <category term="linux" scheme="https://blog.xiaochong2021.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>nginx Rewrite简单示例</title>
    <link href="https://blog.xiaochong2021.top/2019/09/23/nginxrewrite-jian-dan-shi-li/"/>
    <id>https://blog.xiaochong2021.top/2019/09/23/nginxrewrite-jian-dan-shi-li/</id>
    <published>2019-09-23T07:25:46.000Z</published>
    <updated>2019-09-23T07:25:46.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><pre class="line-numbers language-none"><code class="language-none">worker_processes  1;events {    worker_connections  1024;}http {       server {            location /google {                      rewrite (.*) http://www.google.com;        }           location /baidu {                      rewrite (.*) http://www.baidu.com;        }        error_page   500 502 503 504  /50x.html;        location = /50x.html {            root   html;       }   }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>　　按照前面讲的内容以及上面的代码，修改我们自己的配置文件，保存，重新加载nginx，然后点击【访问测试】，在地址栏给出的地址后面分别输入“*/google<em>”、“</em>/baidu*”，是不是会和我的结果一样呢？</p><p>输入“/google”转到谷歌，输入“/baidu”是不是转到百度了呢？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="nginx" scheme="https://blog.xiaochong2021.top/categories/nginx/"/>
    
    
    <category term="nginx" scheme="https://blog.xiaochong2021.top/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>nginx 负载均衡示例</title>
    <link href="https://blog.xiaochong2021.top/2019/09/23/nginx-fu-zai-jun-heng-shi-li/"/>
    <id>https://blog.xiaochong2021.top/2019/09/23/nginx-fu-zai-jun-heng-shi-li/</id>
    <published>2019-09-23T07:21:08.000Z</published>
    <updated>2019-09-23T07:30:03.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><pre class="line-numbers language-none"><code class="language-none">upstream backend{      #定义负载均衡设备的Ip及设备状态      server 127.0.0.1:9090 down;      server 192.168.1.12:8080 weight=2 ;      server 192.168.1.13:6060 max_fails=3 fail_timeout=30s;      server 192.168.1.14:7070 backup;}server{    #…………………………   location /{        proxy_pass http://backend;        #…………………………    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上代码就是对负载均衡应用的示例。</p><p><em>Upstream</em>可对后端服务器进行健康检查。</p><p>a) <em>down</em>表示当前的server暂时不参与负载。</p><p>b) <em>weight</em>默认为1.weight越大，负载的权重就越大。</p><p>c) _max<em>fails</em> ：在fail_timeout时间内对后台服务器请求失败的次数。</p><p>d) _fail<em>timeout</em>:max_fails次失败后，暂停的时间。</p><p>e) <em>backup</em>： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="nginx" scheme="https://blog.xiaochong2021.top/categories/nginx/"/>
    
    
    <category term="nginx" scheme="https://blog.xiaochong2021.top/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>nginx 正向代理示例</title>
    <link href="https://blog.xiaochong2021.top/2019/09/23/nginx-zheng-xiang-dai-li-shi-li/"/>
    <id>https://blog.xiaochong2021.top/2019/09/23/nginx-zheng-xiang-dai-li-shi-li/</id>
    <published>2019-09-23T07:19:43.000Z</published>
    <updated>2019-09-23T07:30:27.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><p>nginx正向代理配置如下：</p><pre class="line-numbers language-none"><code class="language-none">server{  listen       8080;  server_name www.baidu.com;  index index.html index.htm index.php;  root  /home/wwwroot;     location / {         resolver        192.168.8.88;         proxy_pass      $scheme://$http_host$request_uri;         proxy_buffers   256 4k; }   access_log off;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>　　以上配置的注意事项：</p><p>1，不能有hostname。</p><p>2，必须有resolver, 即dns，即上面的x.x.x.x，换成当前机器的DNS服务器ip即可(查看dns方法 cat /etc/resolv.conf 代理使用)。</p><p>3，$http_host和$request_uri是nginx系统变量，保持原样即可。</p><p>　　检测配置文件无误后，重启nginx，在浏览器中添加代理服务器的IP地址，就可以使用该Nginx正向代理了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="nginx" scheme="https://blog.xiaochong2021.top/categories/nginx/"/>
    
    
    <category term="nginx" scheme="https://blog.xiaochong2021.top/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>nginx 虚拟主机示例</title>
    <link href="https://blog.xiaochong2021.top/2019/09/23/nginx-xu-ni-zhu-ji-shi-li/"/>
    <id>https://blog.xiaochong2021.top/2019/09/23/nginx-xu-ni-zhu-ji-shi-li/</id>
    <published>2019-09-23T07:18:14.000Z</published>
    <updated>2019-09-23T07:18:14.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><p>　　Nginx做虚拟主机，尤其是仅仅支持纯静态-html，这是最简单的应用了，可以理解为一个仅支持静态页面的最简单的Web服务器。</p><p>　　例子，同时支持两个虚拟主机（纯静态-html支持）的配置，我们只需要理改server段，如下：</p><pre class="line-numbers language-none"><code class="language-none">server {        listen       80;        server_name  www.baidu.com;        #charset koi8-r;        #access_log  logs/host.access.log  main;        location / {                      root   /root;                       index index.php index.html index.htm;          }        error_page   500 502 503 504  /50x.html;        location = /50x.html {            root   html;        }      }server {        listen       80;        server_name  www.baidu.com;        #charset koi8-r;        #access_log  logs/host.access.log  main;        location / {                      root   /root;                           index index.php index.html index.htm;         }        error_page   500 502 503 504  /50x.html;        location = /50x.html {            root   html;        }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="nginx" scheme="https://blog.xiaochong2021.top/categories/nginx/"/>
    
    
    <category term="nginx" scheme="https://blog.xiaochong2021.top/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>nginx 反向代理示例</title>
    <link href="https://blog.xiaochong2021.top/2019/09/23/nginx-fan-xiang-dai-li-shi-li/"/>
    <id>https://blog.xiaochong2021.top/2019/09/23/nginx-fan-xiang-dai-li-shi-li/</id>
    <published>2019-09-23T07:16:04.000Z</published>
    <updated>2019-09-23T07:16:04.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><p>　　<em>反向代理（Reverse Proxy）</em>是指代理服务器来接收来自Internet上的连接请求，并将请求转发给内部网络上的服务器，并从服务器上得到的结果返回给Internet上请求连接的客户端。</p><p>　　比如要配置后端跑 apache 服务的 ip 和端口，也就是说，我们的目标是实现通过 <a href="http://ip:port/">http://ip:port</a> 能访问到你的网站。配置文件可以修改以下内容，reload nginx就可以了。</p><pre class="line-numbers language-none"><code class="language-none">## Basic reverse proxy server ##    upstream apachephp  {        server ip:8080; #Apache    }    ## Start www.nowamagic.net ##    server {        listen 80;        server_name  www.nowamagic.net;        access_log  logs/quancha.access.log  main;        error_log  logs/quancha.error.log;        root   html;        index  index.html index.htm index.php;        ## send request back to apache ##        location / {            proxy_pass  http://apachephp;                #……………………}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="nginx" scheme="https://blog.xiaochong2021.top/categories/nginx/"/>
    
    
    <category term="nginx" scheme="https://blog.xiaochong2021.top/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>写自己的nginx配置文件</title>
    <link href="https://blog.xiaochong2021.top/2019/09/23/xie-zi-ji-de-nginx-pei-zhi-wen-jian/"/>
    <id>https://blog.xiaochong2021.top/2019/09/23/xie-zi-ji-de-nginx-pei-zhi-wen-jian/</id>
    <published>2019-09-23T07:11:40.000Z</published>
    <updated>2019-09-23T07:11:40.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前面几节中我们已经学过了nginx配置文件中的各个段的配置指令，下面我们就来写一个自己配置文件。如下代码：</p><pre class="line-numbers language-none"><code class="language-none">worker_processes  1;events {    worker_connections  1024;}http {       server {            location / {                      #root   html;      #定义服务器的默认网站根目录位置                      #index index.php index.html index.htm;   #定义首页索引文件的名称                      proxy_pass http://www.baidu.com;             }            error_page   500 502 503 504  /50x.html;            location = /50x.html {                root   html;           }         }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>　　这样我们自己的配置文件就完成了，先将nginx的服务停止，然后我们用<em>nginx -c <em>.conf</em>命令来重新启动nginx，</em>.conf 为我们自己的配置文件所在的路径，nginx启动以后，然后点击【访问测试】，看看会出现什么情况，是不是已经转到我们所配置的站点了。</p><p>　　在右面的编辑页面中编辑一个配置文件，我自己的配置文件名为Mynginx.conf,其中的内容就是以上面代码的内容，保存在/etc/nginx目录下，完成以后我们做如下操作：</p><pre class="line-numbers language-none"><code class="language-none">nginx -s stop   nginx -c /etc/nginx/Mynginx.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后点击【访问测试】</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="nginx" scheme="https://blog.xiaochong2021.top/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>nginx rewrite规则</title>
    <link href="https://blog.xiaochong2021.top/2019/09/23/nginxrewrite-gui-ze/"/>
    <id>https://blog.xiaochong2021.top/2019/09/23/nginxrewrite-gui-ze/</id>
    <published>2019-09-23T07:09:37.000Z</published>
    <updated>2019-09-23T07:09:37.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><p>　　Nginx Rewrite 规则相关指令有if,rewrite,set,return,break等，其中最关键的就是rewrite。一个简单的Nginx Rewrite规则语法如下：</p><p><code>rewrite ^/b/(.\*)\.html /play.php?video=$1 break;</code></p><p><strong>正则表达式匹配，</strong>其中：</p><ol><li>~ 为区分大小写匹配；  </li><li>~* 为不区分大小写匹配；  </li><li>!<del>和!</del>*分别为区分大小写不匹配及不区分大小写不匹配。</li></ol><p><strong>文件及目录匹配，</strong>其中：</p><ol><li>-f和!-f用来判断是否存在文件；  </li><li>-d和!-d用来判断是否存在目录；  </li><li>-e和!-e用来判断是否存在文件或目录；  </li><li>-x和!-x用来判断文件是否可执行。  </li></ol><p><strong>flag标记有：</strong></p><ol><li>last 相当于Apache里的[L]标记，表示完成rewrite；</li><li>break 终止匹配, 不再匹配后面的规则；</li><li>redirect 返回302临时重定向 地址栏会显示跳转后的地址；</li><li>permanent 返回301永久重定向 地址栏会显示跳转后的地址。</li></ol><p>当然除了这些以外，Rewrite规则中还会用到一些相应的全局变量，如$args，$url等等</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="nginx" scheme="https://blog.xiaochong2021.top/categories/nginx/"/>
    
    
    <category term="nginx" scheme="https://blog.xiaochong2021.top/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>nginx location配置</title>
    <link href="https://blog.xiaochong2021.top/2019/09/23/nginxlocation-pei-zhi/"/>
    <id>https://blog.xiaochong2021.top/2019/09/23/nginxlocation-pei-zhi/</id>
    <published>2019-09-23T07:08:05.000Z</published>
    <updated>2019-09-23T07:08:05.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><p>语法规则： <em>location [=|<del>|</del></em>|^~] /uri/ { … }*</p><p>| — | — |<br>| 通配符 |  说明 |<br>| =   |开头表示精确匹配 |<br>| ^~ |  开头表示uri以某个常规字符串开头，理解为匹配 url路径即可 |<br>| ~ |  开头表示区分大小写的正则匹配 |<br>| !~ |  区分大小写不匹配 |<br>| !~* |  不区分大小写不匹配 |<br>| ~* |  开头表示不区分大小写的正则匹配 |<br>| / |  通用匹配，任何请求都会匹配到 |</p><p>　　首先匹配 =，其次匹配^~, 其次是按文件中顺序的正则匹配，最后是交给 / 通用匹配。当有匹配成功时候，停止匹配，按当前匹配规则处理请求。</p><pre class="line-numbers language-none"><code class="language-none">location = / {   #规则A}location = /login {   #规则B}location ^~ /static/ {   #规则C}location ~ \.(gif|jpg|png|js|css)$ {   #规则D}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>　　那么产生的效果如下：</p><p>访问根目录/， 比如<a href="http://localhost/">http://localhost/</a> 将匹配规则A；<br>访问 <a href="http://localhost/login">http://localhost/login</a> 将匹配规则B；<br>访问 <a href="http://localhost/static/a.html">http://localhost/static/a.html</a> 将匹配规则C；<br>访问 <a href="http://localhost/a.gif">http://localhost/a.gif</a>, <a href="http://localhost/b.jpg">http://localhost/b.jpg</a> 将匹配规则D。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="nginx" scheme="https://blog.xiaochong2021.top/categories/nginx/"/>
    
    
    <category term="nginx" scheme="https://blog.xiaochong2021.top/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>nginx 负载均衡</title>
    <link href="https://blog.xiaochong2021.top/2019/09/23/nginx-fu-zai-jun-heng/"/>
    <id>https://blog.xiaochong2021.top/2019/09/23/nginx-fu-zai-jun-heng/</id>
    <published>2019-09-23T06:46:50.000Z</published>
    <updated>2019-09-23T07:34:49.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>　　<em>负载均衡</em>（又称为负载分担），英文名称为Load Balance，其意思就是将负载（工作任务）进行平衡、分摊到多个操作单元上进行执行，例如Web服务器、FTP服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。</p><p>　　nginx的<em>upstream</em>目前支持4种方式的分配</p><p>　　1)、<em>default</em>（默认） 每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</p><p>　　2)、<em>weight</em> 指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</p><p>　　3)、<em>ip_hash</em> 每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。</p><p>　　4)、<em>fair</em>（第三方） 按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p><pre class="line-numbers language-none"><code class="language-none">upstream ixdba.net{    ip_hash;    server 192.168.12.133:80;    server 192.168.12.134:80  down;    server 192.168.12.135:8009  max_fails=3  fail_timeout=20s;    server 192.168.12.136:8080;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>　　<em>upstream</em>是Nginx的HTTP Upstream模块，这个模块通过一个简单的调度算法来实现客户端IP到后端服务器的负载均衡。在上面的设定中，通过upstream指令指定了一个负载均衡器的名称ixdba.net。这个名称可以任意指定，在后面需要的地方直接调用即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="nginx" scheme="https://blog.xiaochong2021.top/categories/nginx/"/>
    
    
    <category term="nginx" scheme="https://blog.xiaochong2021.top/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>一位年轻的董事长给大学生的18条好建议</title>
    <link href="https://blog.xiaochong2021.top/2019/09/23/yi-wei-nian-qing-de-dong-shi-chang-gei-da-xue-sheng-de-18-tiao-hao-jian-yi/"/>
    <id>https://blog.xiaochong2021.top/2019/09/23/yi-wei-nian-qing-de-dong-shi-chang-gei-da-xue-sheng-de-18-tiao-hao-jian-yi/</id>
    <published>2019-09-23T06:46:50.000Z</published>
    <updated>2019-09-23T07:34:49.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>做每件事情之前一定要考虑好，从而才能做到胸有成竹啊！</p><h2 id="一位年轻的董事长给大学生的18条好建议"><a href="#一位年轻的董事长给大学生的18条好建议" class="headerlink" title="一位年轻的董事长给大学生的18条好建议"></a>一位年轻的董事长给大学生的18条好建议</h2><p>　　1.一定要有独立的人格、独立的思想。一个经过独立思考而坚持错误观点的人比一个不假思索而接受正确观点的人更值得肯定。不要成为灌输教育的牺牲品。</p><p>　　2.仕途，商界，学术。大致说来，每个人都注定要走上三条道路中的某一条。在进行职业生涯规划的时候，不妨以此作为思考的出发点。根据不同的职业生涯规划来塑造各自的核心竞争力。只有知道自己以后要做什么，才能知道自己应该学什么。 </p><p>　　3.专业无冷热，学校无高低。没有哪个用人单位会认为你代表了你的学校或者你的专业。<br>千万不要因为你是名牌大学或者热门专业而沾沾自喜，也大可不必因为你的学校不好或者专业冷门而自卑。</p><p>　　4.千招会，不如一招熟。十个百分之十并不是百分之百，而是零。如果你有十项工作，每项都会做百分之十，那么，在用人单位眼中，你什么都不会。所以，你必须要让自己具备核心竞争力，“通才”只有在“专才”的基础上才有意义。</p><p>　　5.不逃课的学生不是好学生。什么课都不逃，跟什么课都逃掉没什么两样。一定要掌握学习的主动性，不要像读中学一样被老师牵着鼻子走。逃课没有错，但是不要逃错课。同时，既要逃课，又要让老师给高分。</p><p>　　6.一定要学会理财。对于贫困生来说，首先要做的不是挣钱，而是省钱。很多大学生读书的时候一掷千金，可是，毕业以后一个月的工资还不够交半个月的房租。</p><p>　　7.大部分女生将电脑当成了影碟机，大部分男生将电脑当成了游戏机。大学生要掌握必要的计算机操作能力，但是，很多时候电脑会成为浪费时间的堂而皇之的借口。有电脑的大学生非常多，可是，这中间很多人可能大学毕业的时候还不会Excel，不会做一个像样的PPT。</p><p>　　8.做事不如做人，人脉决定成败。一个人有多少钱并不是指他拥有多少钱的所有权，而是指他拥有多少钱的使用权。一个人具备多少能力，不只是说他一个人的时候能做什么，还包括他能通过别人做什么。一个人赚的钱，12.5%是靠自身的知识，87.5%则来自人脉关系。三十岁以前靠专业赚钱，三十岁以后拿人脉赚钱。所以，请好好珍惜大学期间建立起来的人脉关系。这几年你认识的朋友可能会是你毕业以后最可宝贵的财富。</p><p>　　9.互联网固然威力无穷，但是，如果你沉迷于网络聊天，或者沉迷于网络游戏，浪费的金钱倒是可以弥补，荒废的青春就无可追寻了。轻舞飞扬已经红颜薄命了，而痞子蔡却继续跟别的女孩发生着一次又一次的亲密接触。对于很多大学生而言，网吧就是一个血淋淋的黑洞。</p><p>　　10.爱情是不期而至的，可以期待，但不可以制造。花开堪折方须折，莫让鲜花败残枝。一个有一万块钱的人为你花掉一百元，你只占了他的百分之一；而一个只有十块钱的人为你花掉十块，你就成了他的全部。</p><p>　　11.研究生扩招的速度是30%，也就意味着硕士学历贬值的速度是30%。千万不要以为考研究生就是积极进取的表现。对于很多人而言，考研不过是一种消极逃避的方式罢了。对于绝大多数人而言，读研究生纯粹是浪费时间浪费金钱，立志从事科研、学术的人及其他少数人除外。</p><p>　　12.不要一门心思想着出国，更加不要迷信外国的月亮比中国圆。削尖脑袋记GRE词汇很可能是一件非常愚蠢也非常可悲的事情。既然全世界的公司都想到中国的市场上来瓜分蛋糕，为什么中国人还要一门心思到国外去留学然后给外国人打工？</p><p>　　13.人才市场就是一个地雷阵。通过多种方式求职固然没有错，但是千万不要饥不择食。只要用人单位一说要你交钱，你掉头就走便是了。</p><p>　　14.求职简历必须突出自己的核心竞争力。求职的时候大可不必像严守一那样“有一说一”，必要的时候恰到好处地说一些谎言是非常有用的。一份求职简历只要用一张A4纸做个表格就足够了。很多女生的求职简历就像是写真集，不但浪费钱，而且对求职毫无用处。面试其实是有规律的，每次面试的时候只要背标准答案就行了……</p><p>　　15.垃圾是放错位置的人才。所以，在找工作的时候一定要把自己放到那个让你成为人才而不是垃圾的职位上。当然，前提是你要知道自己究竟想做什么、究竟适合做什么。世界上最大的悲剧莫过于有太多的年轻人从来没有发现自己真正想做什么。骑驴找马固然没错，可是，并非随便找一头驴就能找到千里马。所以，一定要重视第一份工作。</p><p>　　16.大公司是做人，小公司是做事。进入公司工作以后，必须尽快融入写字楼政治。职员能否得到提升，很大程度不在于是否努力，而在于老板对你的赏识程度。在写字楼的政治斗争中，一定要学会自我保护。</p><p>　　17.瘦死的骆驼比马大。撑死胆大的，饿死胆小的。一定要有创业的勇气和魄力。如果你一直满足于给别人打工，那么，不管你工资多高，永远都只能是一个可怜的穷光蛋。就算月薪两万，在深圳上海那种地方，一年的存款还买不来一个小小的洗手间。</p><p>　　18.大学期间一定要多去图书馆多去自习室。很多书你现在不读，一辈子就再也没有机会去读了。虽然不是每本书看了都一定有用，但是，因为你不知道究竟哪本书以后会有用，所以只好多看书，并且抛弃那些过于功利的想法。尽管每次网到鱼的不过是一个网眼，但要想捕到鱼，就必须要编织一张网。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="感悟" scheme="https://blog.xiaochong2021.top/categories/%E6%84%9F%E6%82%9F/"/>
    
    
    <category term="感悟" scheme="https://blog.xiaochong2021.top/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
</feed>
